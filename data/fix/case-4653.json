{
    "case_id": "case-4653",
    "repo_name": "apache/maven-archetype",
    "file_path": "maven-archetype-plugin/src/main/java/org/apache/maven/archetype/ui/generation/DefaultArchetypeGenerationConfigurator.java",
    "code_snippet": "    public static class RequiredPropertyComparator implements Comparator<String> {\n        private final ArchetypeConfiguration archetypeConfiguration;\n\n        private Map<String, Set<String>> propertyReferenceMap;\n\n        public RequiredPropertyComparator(ArchetypeConfiguration archetypeConfiguration) {\n            this.archetypeConfiguration = archetypeConfiguration;\n            propertyReferenceMap = computePropertyReferences();\n        }\n\n        @Override\n        public int compare(String left, String right) {\n            if (references(right, left)) {\n                return 1;\n            }\n\n            if (references(left, right)) {\n                return -1;\n            }\n\n            return Integer.compare(\n                    propertyReferenceMap.get(left).size(),\n                    propertyReferenceMap.get(right).size());\n        }\n\n        private Map<String, Set<String>> computePropertyReferences() {\n            Map<String, Set<String>> result = new HashMap<>();\n\n            List<String> requiredProperties = archetypeConfiguration.getRequiredProperties();\n\n            final InternalContextAdapterImpl velocityContextAdapter =\n                    new InternalContextAdapterImpl(new VelocityContext());\n\n            final RuntimeServices velocityRuntime = RuntimeSingleton.getRuntimeServices();\n\n            for (String propertyName : requiredProperties) {\n                final Set<String> referencedPropertyNames = new LinkedHashSet<>();\n\n                String defaultValue = archetypeConfiguration.getDefaultValue(propertyName);\n                if (StringUtils.contains(defaultValue, \"${\")) {\n                    try {\n                        final boolean dumpNamespace = false;\n                        SimpleNode node = RuntimeSingleton.parse(\n                                new StringReader(defaultValue), propertyName + \".default\", dumpNamespace);\n\n                        node.init(velocityContextAdapter, velocityRuntime);\n\n                        node.jjtAccept(\n                                new BaseVisitor() {\n                                    @Override\n                                    public Object visit(ASTReference node, Object data) {\n                                        referencedPropertyNames.add(node.getRootString());\n                                        return super.visit(node, data);\n                                    }\n                                },\n                                velocityRuntime);\n                    } catch (ParseException e) {\n                        throw new IllegalStateException(\"Unparsable default value for property \" + propertyName, e);\n                    }\n                }\n\n                referencedPropertyNames.retainAll(archetypeConfiguration.getRequiredProperties());\n\n                // handle the case that a property expression #set()s itself:\n                referencedPropertyNames.remove(propertyName);\n                result.put(propertyName, referencedPropertyNames);\n            }\n\n            return result;\n        }\n\n        /**\n         * Learn whether one property references another. Semantically, \"references\n         * {@code targetProperty}, {@code sourceProperty} (does).\"\n         *\n         * @param targetProperty {@link String} denoting property for which the state of\n         *        being-referenced-by-the-property-denoted-by {@code sourceProperty} is desired\n         * @param sourceProperty {@link String} denoting property for which the state of\n         *        references-the-property-denoted-by {@code targetProperty} is desired\n         * @return {@code boolean}\n         */\n        private boolean references(String targetProperty, String sourceProperty) {\n            if (targetProperty.equals(sourceProperty)) {\n                return false;\n            }\n            synchronized (this) {\n                if (!propertyReferenceMap.containsKey(sourceProperty))\n                // something has changed\n                {\n                    this.propertyReferenceMap = computePropertyReferences();\n                }\n            }\n            Set<String> referencedProperties = propertyReferenceMap.get(sourceProperty);\n            if (referencedProperties.contains(targetProperty)) {\n                return true;\n            }\n            for (String referencedProperty : referencedProperties) {\n                if (references(targetProperty, referencedProperty)) {\n                    return true;\n                }\n            }\n            return false;\n",
    "line_range": [
        306,
        407
    ],
    "command_specific_fields": {
        "static_analyzer": "spotbugs",
        "rule": "spotbugs-SE_COMPARATOR_SHOULD_BE_SERIALIZABLE",
        "analyzer_error": "Comparator doesn't implement Serializable"
    }
}