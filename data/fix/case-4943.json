{
    "case_id": "case-4943",
    "repo_name": "owasp/www-project-csrfguard",
    "file_path": "csrfguard/src/main/java/org/owasp/csrfguard/config/overlay/ExpirableCache.java",
    "code_snippet": "  static long MAX_TIME_TO_LIVE_MILLIS = 1000 * 60 * 60 * 24; //1 day\n\n  /** time to live for content (when not specified this is one day, and max one day) */\n  long defaultTimeToLiveInMillis = MAX_TIME_TO_LIVE_MILLIS;\n  \n  /** time between looking for evictions in millis, default to two minutes */\n  static long TIME_BETWEEN_EVICTIONS_MILLIS = 2 * 60 * 1000;\n  \n  /** last time the cache was checked for evictions */\n  long lastEvictionCheck = System.currentTimeMillis();\n  \n  /** cache map */\n  private Map<K,ExpirableValue<V>> cache = new HashMap<K,ExpirableValue<V>>();\n  \n  /** number of elements inserted into the cache */\n  private int cacheInserts = 0;\n  \n  /** numebr of times an element was retrieved from cache successfully */\n  private int cacheHits = 0;\n  \n  /** number of evictions from cache when thigns expire */\n  private int cacheEvictions = 0;\n  \n  /** global number of elements inserted into the cache, no need to synchronize */\n  private static int globalCacheInserts = 0;\n  \n  /** numebr of times an element was retrieved from cache successfully, no need to synchronize */\n  private static int globalCacheHits = 0;\n  \n  /** number of evictions from cache when thigns expire, no need to synchronize */\n  private static int globalCacheEvictions = 0;\n  \n  /** when was the last clear of all */\n  private static long lastClearStatic = -1;\n  \n  /** when was the last clear of this instance */\n  private long lastClear = System.currentTimeMillis();\n  \n  /**\n   * \n   */\n  public ExpirableCache() {\n    super();\n  }\n  \n  /**\n   * delete the cache\n   *\n   */\n  public synchronized void clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * @param defaultTimeToLiveInMinutes time in minutes is the default cache time to live for content\n   */\n  public ExpirableCache(int defaultTimeToLiveInMinutes) {\n    super();\n    if (defaultTimeToLiveInMinutes <= 0) {\n      throw new RuntimeException(\"Time to live in minutes must be greater than 0\");\n    }\n    //make sure this is less than the max\n    long newTimeToLiveMillis = (long)defaultTimeToLiveInMinutes * 60 * 1000;\n    if (newTimeToLiveMillis < MAX_TIME_TO_LIVE_MILLIS) {\n      this.defaultTimeToLiveInMillis = newTimeToLiveMillis;\n    }\n  }\n\n  /**\n   * unit of time for expirable cache\n   * @author mchyzer\n   *\n   */\n  public static enum ExpirableCacheUnit {\n    /** minutes */\n    MINUTE {\n\n      /** \n       * @see ExpirableCacheUnit#defaultTimeToLiveMillis(int)\n       */\n      @Override\n      public long defaultTimeToLiveMillis(int input) {\n        return (long)input * 60 * 1000;\n      }\n    },\n    \n    /** seconds */\n    SECOND {\n\n      /** \n       * @see ExpirableCacheUnit#defaultTimeToLiveMillis(int)\n       */\n      @Override\n      public long defaultTimeToLiveMillis(int input) {\n        return (long)input * 1000;\n      }\n    };\n    \n    /** \n     * default time to live based on units\n     * @param input A number of units (seconds or minutes) before cache expires to be converted into milliseconds\n     * @return the millis\n     */\n    public abstract long defaultTimeToLiveMillis(int input);\n    \n  }\n  \n  /**\n   * @param defaultTimeToLive time in whatever unit is the default cache time to live for content\n   * @param expirableCacheUnit is minutes or seconds\n   */\n  public ExpirableCache(ExpirableCacheUnit expirableCacheUnit, int defaultTimeToLive) {\n    super();\n    if (defaultTimeToLive <= 0) {\n      throw new RuntimeException(\"Time to live in minutes must be greater than 0\");\n    }\n    //make sure this is less than the max\n    long newTimeToLiveMillis = expirableCacheUnit.defaultTimeToLiveMillis(defaultTimeToLive);\n    if (newTimeToLiveMillis < MAX_TIME_TO_LIVE_MILLIS) {\n      this.defaultTimeToLiveInMillis = newTimeToLiveMillis;\n    }\n  }\n\n  /**\n   * expose the length of cache\n   * @return length of cache\n   */\n  public long getDefaultTimeToLiveInMillis() {\n    return this.defaultTimeToLiveInMillis;\n  }\n\n  /**\n   * put a value into the cache, accept the default time to live for this cache\n   * @param key key type\n   * @param value value type\n   */\n  public synchronized void put(K key, V value) {\n    this.putHelper(key, value, this.defaultTimeToLiveInMillis);\n  }\n  \n  /**\n   * put a value into the cache, accept the default time to live for this cache\n   * @param key key type\n   * @param value value type\n   * @param timeToLiveInMinutes time to live for this item in minutes.\n   * If -1 then use the default\n   */\n  public synchronized void put(K key, V value, int timeToLiveInMinutes) {\n    \n    //see if the default\n    if (timeToLiveInMinutes == -1) {\n      this.put(key,value);\n      return;\n    }\n    \n    if (timeToLiveInMinutes <= 0) {\n      throw new RuntimeException(\"Time to live in minutes must be greater than 0\");\n    }\n    this.putHelper(key, value, (long)timeToLiveInMinutes * 60 * 1000);\n  }\n\n  /**\n   * put a value into the cache, accept the default time to live for this cache\n   * @param key key type\n   * @param value value type\n   * @param proposedTimeToLiveInMillis millis time to live\n   */\n  synchronized void putHelper(K key, V value, long proposedTimeToLiveInMillis) {\n    \n    this.checkForEvictions(true);\n    long newTimeToLiveInMillis = this.defaultTimeToLiveInMillis;\n    // don't use what was inputted if it is out of range\n    if (proposedTimeToLiveInMillis > 0 \n        && proposedTimeToLiveInMillis <= ExpirableCache.MAX_TIME_TO_LIVE_MILLIS) {\n      newTimeToLiveInMillis = proposedTimeToLiveInMillis;\n    }\n    ExpirableValue<V> expirableValue = new ExpirableValue<V>(value, newTimeToLiveInMillis);\n    this.cache.put(key, expirableValue);\n    this.cacheInserts++;\n    globalCacheInserts++;\n  }\n  \n  /**\n   * clear out all caches everywhere (session, request, context, etc)\n   */\n  public static void clearAll() {\n    lastClearStatic = System.currentTimeMillis();\n  }\n  \n  /**\n   * check and remove elements that are stale\n   * @param onlyCheckIfNeeded true if only check every so often (e.g. every two minutes)\n   */\n  public synchronized void checkForEvictions(boolean onlyCheckIfNeeded) {\n    long now = System.currentTimeMillis();\n    \n    //first see if there is an all clear\n    if (lastClearStatic > this.lastClear) {\n      this.clear();\n      this.lastClear = now;\n      return;\n    }\n    \n    if (onlyCheckIfNeeded) {\n      if (now - this.lastEvictionCheck < ExpirableCache.TIME_BETWEEN_EVICTIONS_MILLIS) {\n        return;\n      }\n    }\n    \n    //go through all elements, evict if stale\n    Set<K> keySet = this.cache.keySet();\n    Iterator<K> keyIterator = keySet.iterator();\n    while (keyIterator.hasNext()) {\n      K key = keyIterator.next();\n      ExpirableValue<V> expirableValue = this.cache.get(key);\n      if (expirableValue.expired()) {\n        keyIterator.remove();\n        this.cacheEvictions++;\n        ExpirableCache.globalCacheEvictions++;\n      }\n    }\n    \n    //set that we just checked\n    this.lastEvictionCheck = now;\n  }\n  \n  /**\n   * get a value or null if not there or expired\n   * this will check for eviction, and evict if evictable\n   * @param key key type\n   * @return the value or null if not there or evicted\n   */\n  public synchronized V get(K key) {\n\n    this.checkForEvictions(true);\n    return this.getHelper(key);\n  }\n  /**\n   * get a value or null if not there or expired\n   * this will check for eviction, and evict if evictable\n   * @param key key for the cached value\n   * @return the value or null if not there or evicted\n   */\n  private synchronized V getHelper(K key) {\n\n    ExpirableValue<V> value = this.cache.get(key);\n    if (value == null) {\n      // shouldn't have a key with no value, probably doesn't exist, but just in case\n      this.cache.remove(key);\n      return null;\n    }\n    if (value.expired()) {\n      this.cacheEvictions++;\n      ExpirableCache.globalCacheEvictions++;\n      this.cache.remove(key);\n      return null;\n    }\n    V content = value.getContent();\n    this.cacheHits++;\n    ExpirableCache.globalCacheHits++;\n    return content;\n  }\n  \n  /**\n   * number of elements in map (and check for \n   * @param evictEvictables true if we should evict values that are stale \n   * (even if recently checked)\n   * @return the number of elements\n   */\n  public synchronized int size(boolean evictEvictables) {\n    if (evictEvictables) {\n      this.checkForEvictions(false);\n    }\n    return this.cache.size();\n  }\n\n  \n  /**\n   * number of items inserted into the cache\n   * @return Returns the cacheInserts.\n   */\n  public int getCacheInserts() {\n    return this.cacheInserts;\n  }\n\n  \n  /**\n   * number of items evicted from cache\n   * @return Returns the cacheEvictions.\n   */\n  public int getCacheEvictions() {\n    return this.cacheEvictions;\n  }\n\n  \n  /**\n   * number of items successfully retrieved from cache\n   * @return Returns the cacheHits.\n   */\n  public int getCacheHits() {\n    return this.cacheHits;\n  }\n\n  /**\n   * string representation of cache\n   * @see java.lang.Object#toString()\n   */\n  @Override\npublic String toString() {\n    this.checkForEvictions(true);\n    return this.getClass().getSimpleName() + \": size: \" + this.size(false)\n      + \", cacheHits: \" + this.getCacheHits() + \", cacheInserts: \" \n      + this.getCacheInserts() + \", cacheEvictions: \" + this.cacheEvictions;\n  }\n  \n  /**\n   * string representation of cache\n   * @return the string value\n   */\n  public static String staticToString() {\n    return \"ExpirableCacheGlobal, cacheHits: \" + globalCacheHits + \", cacheInserts: \" \n",
    "line_range": [
        64,
        384
    ],
    "command_specific_fields": {
        "static_analyzer": "spotbugs",
        "rule": "spotbugs-SE_NO_SERIALVERSIONID",
        "analyzer_error": "Class is Serializable, but doesn't define serialVersionUID"
    },
    "prompt": ""
}