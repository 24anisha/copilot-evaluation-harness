{
    "case_id": "case-183",
    "repo_name": "nock/nock",
    "file_path": "lib/playback_interceptor.js",
    "code_snippet": " */\n\nfunction playbackInterceptor({\n\n  req,\n\n  socket,\n\n  options,\n\n  requestBodyString,\n\n  requestBodyIsUtf8Representable,\n\n  response,\n\n  interceptor,\n\n}) {\n\n  const { logger } = interceptor.scope\n\n\n\n  function start() {\n\n    req.headers = req.getHeaders()\n\n\n\n    interceptor.scope.emit('request', req, interceptor, requestBodyString)\n\n\n\n    if (typeof interceptor.errorMessage !== 'undefined') {\n\n      let error\n\n      if (typeof interceptor.errorMessage === 'object') {\n\n        error = interceptor.errorMessage\n\n      } else {\n\n        error = new Error(interceptor.errorMessage)\n\n      }\n\n\n\n      const delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs\n\n      common.setTimeout(() => req.destroy(error), delay)\n\n      return\n\n    }\n\n\n\n    // This will be null if we have a fullReplyFunction,\n\n    // in that case status code will be set in `parseFullReplyResult`\n\n    response.statusCode = interceptor.statusCode\n\n\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n\n    response.rawHeaders = [...interceptor.rawHeaders]\n\n    logger('response.rawHeaders:', response.rawHeaders)\n\n\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n\n    // The only reason we do this is so that it's available inside reply functions.\n\n    // It would be better to pass the request as an argument to the functions instead.\n\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n\n    // is the signature we want to go with going forward.\n\n    interceptor.req = req\n\n\n\n    if (interceptor.replyFunction) {\n\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n\n\n      let fn = interceptor.replyFunction\n\n      if (fn.length === 3) {\n\n        // Handle the case of an async reply function, the third parameter being the callback.\n\n        fn = util.promisify(fn)\n\n      }\n\n\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n\n        .then(continueWithResponseBody)\n\n        .catch(err => req.destroy(err))\n\n      return\n\n    }\n\n\n\n    if (interceptor.fullReplyFunction) {\n\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n\n\n      let fn = interceptor.fullReplyFunction\n\n      if (fn.length === 3) {\n\n        fn = util.promisify(fn)\n\n      }\n\n\n\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n\n        .then(continueWithFullResponse)\n\n        .catch(err => req.destroy(err))\n\n      return\n\n    }\n\n\n\n    if (\n\n      common.isContentEncoded(interceptor.headers) &&\n\n      !common.isStream(interceptor.body)\n\n    ) {\n\n      //  If the content is encoded we know that the response body *must* be an array\n\n      //  of response buffers which should be mocked one by one.\n\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n\n      //  buffer by buffer and not one single merged buffer)\n\n      const bufferData = Array.isArray(interceptor.body)\n\n        ? interceptor.body\n\n        : [interceptor.body]\n\n      const responseBuffers = bufferData.map(data => Buffer.from(data, 'hex'))\n\n      const responseBody = new ReadableBuffers(responseBuffers)\n\n      continueWithResponseBody(responseBody)\n\n      return\n\n    }\n\n\n\n    // If we get to this point, the body is either a string or an object that\n\n    // will eventually be JSON stringified.\n\n    let responseBody = interceptor.body\n\n\n\n    // If the request was not UTF8-representable then we assume that the\n\n    // response won't be either. In that case we send the response as a Buffer\n\n    // object as that's what the client will expect.\n\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n\n      // Try to create the buffer from the interceptor's body response as hex.\n\n      responseBody = Buffer.from(responseBody, 'hex')\n\n\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n\n      if (\n\n        !responseBody ||\n\n        (interceptor.body.length > 0 && responseBody.length === 0)\n\n      ) {\n\n        // We fallback on constructing buffer from utf8 representation of the body.\n\n        responseBody = Buffer.from(interceptor.body, 'utf8')\n\n      }\n\n    }\n\n\n\n    return continueWithResponseBody(responseBody)\n\n  }\n\n\n\n  function continueWithFullResponse(fullReplyResult) {\n\n    let responseBody\n\n    try {\n\n      responseBody = parseFullReplyResult(response, fullReplyResult)\n\n    } catch (err) {\n\n      req.destroy(err)\n\n      return\n\n    }\n\n\n\n    continueWithResponseBody(responseBody)\n\n  }\n\n\n\n  function prepareResponseHeaders(body) {\n\n    const defaultHeaders = [...interceptor.scope._defaultReplyHeaders]\n\n\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n\n    const isJSON =\n\n      body !== undefined &&\n\n      typeof body !== 'string' &&\n\n      !Buffer.isBuffer(body) &&\n\n      !common.isStream(body)\n\n\n\n    if (isJSON) {\n\n      defaultHeaders.push('Content-Type', 'application/json')\n\n    }\n\n\n\n    response.rawHeaders.push(\n\n      ...selectDefaultHeaders(response.rawHeaders, defaultHeaders),\n\n    )\n\n\n\n    // Evaluate functional headers.\n\n    common.forEachHeader(response.rawHeaders, (value, fieldName, i) => {\n\n      if (typeof value === 'function') {\n\n        response.rawHeaders[i + 1] = value(req, response, body)\n\n      }\n\n    })\n\n\n\n    response.headers = common.headersArrayToObject(response.rawHeaders)\n\n  }\n\n\n\n  function continueWithResponseBody(rawBody) {\n\n    prepareResponseHeaders(rawBody)\n\n    const bodyAsStream = convertBodyToStream(rawBody)\n\n    bodyAsStream.pause()\n\n\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n\n    bodyAsStream.on('data', function (chunk) {\n\n      response.push(chunk)\n\n    })\n\n    bodyAsStream.on('end', function () {\n\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n\n      response.complete = true\n\n      response.push(null)\n\n\n\n      interceptor.scope.emit('replied', req, interceptor)\n\n    })\n\n    bodyAsStream.on('error', function (err) {\n\n      response.emit('error', err)\n\n    })\n\n\n\n    const { delayBodyInMs, delayConnectionInMs } = interceptor\n\n\n\n    function respond() {\n\n      if (common.isRequestDestroyed(req)) {\n\n        return\n\n      }\n\n\n\n      // Even though we've had the response object for awhile at this point,\n\n      // we only attach it to the request immediately before the `response`\n\n      // event because, as in Node, it alters the error handling around aborts.\n\n      req.res = response\n\n      response.req = req\n\n\n\n      logger('emitting response')\n\n      req.emit('response', response)\n\n\n\n      common.setTimeout(() => bodyAsStream.resume(), delayBodyInMs)\n\n    }\n\n\n\n    socket.applyDelay(delayConnectionInMs)\n\n    common.setTimeout(respond, delayConnectionInMs)\n\n  }\n\n\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n\n  // correct events are emitted first ('socket', 'finish') and any aborts in the queue or\n\n  // called during a 'finish' listener can be called.\n\n  common.setImmediate(() => {\n\n    if (!common.isRequestDestroyed(req)) {\n\n      start()\n\n    }\n\n  })\n\n}\n",
    "line_range": [
        113,
        325
    ],
    "command_specific_fields": {
        "method_name": "playbackInterceptor"
    },
    "language": "javascript",
    "commit": "2b7836d36c4f22f449b36ad9fd1fff2d14e9200d",
    "prompt": ""
}