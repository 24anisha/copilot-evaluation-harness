{
    "case_id": "case-1378",
    "repo_name": "dbcli/mycli",
    "file_path": "mycli/packages/parseutils.py",
    "code_snippet": "\n\ndef extract_from_part(parsed, stop_at_punctuation=True):\n    tbl_prefix_seen = False\n    for item in parsed.tokens:\n        if tbl_prefix_seen:\n            if is_subselect(item):\n                for x in extract_from_part(item, stop_at_punctuation):\n                    yield x\n            elif stop_at_punctuation and item.ttype is Punctuation:\n                return\n            # Multiple JOINs in the same query won't work properly since\n            # \"ON\" is a keyword and will trigger the next elif condition.\n            # So instead of stooping the loop when finding an \"ON\" skip it\n            # eg: 'SELECT * FROM abc JOIN def ON abc.id = def.abc_id JOIN ghi'\n            elif item.ttype is Keyword and item.value.upper() == \"ON\":\n                tbl_prefix_seen = False\n                continue\n            # An incomplete nested select won't be recognized correctly as a\n            # sub-select. eg: 'SELECT * FROM (SELECT id FROM user'. This causes\n            # the second FROM to trigger this elif condition resulting in a\n            # StopIteration. So we need to ignore the keyword if the keyword\n            # FROM.\n            # Also 'SELECT * FROM abc JOIN def' will trigger this elif\n            # condition. So we need to ignore the keyword JOIN and its variants\n            # INNER JOIN, FULL OUTER JOIN, etc.\n            elif item.ttype is Keyword and (not item.value.upper() == \"FROM\") and (not item.value.upper().endswith(\"JOIN\")):\n                return\n            else:\n                yield item\n        elif (item.ttype is Keyword or item.ttype is Keyword.DML) and item.value.upper() in (\n            \"COPY\",\n            \"FROM\",\n            \"INTO\",\n            \"UPDATE\",\n            \"TABLE\",\n            \"JOIN\",\n        ):\n            tbl_prefix_seen = True\n        # 'SELECT a, FROM abc' will detect FROM as part of the column list.\n        # So this check here is necessary.\n        elif isinstance(item, IdentifierList):\n            for identifier in item.get_identifiers():\n",
    "line_range": [
        73,
        115
    ],
    "command_specific_fields": {
        "method_name": "extract_from_part"
    },
    "language": "python",
    "commit": "af5a17d980450e184cfc25e56e0e91a1389d378d",
    "prompt": ""
}