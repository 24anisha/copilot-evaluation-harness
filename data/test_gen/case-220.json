{
    "case_id": "case-220",
    "repo_name": "tj/commander.js",
    "file_path": "lib/command.js",
    "code_snippet": "\n\n  _executeSubCommand(subcommand, args) {\n\n    args = args.slice();\n\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n\n\n    function findFile(baseDir, baseName) {\n\n      // Look for specified file\n\n      const localBin = path.resolve(baseDir, baseName);\n\n      if (fs.existsSync(localBin)) return localBin;\n\n\n\n      // Stop looking if candidate already has an expected extension.\n\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n\n\n      // Try all the extensions.\n\n      const foundExt = sourceExt.find((ext) =>\n\n        fs.existsSync(`${localBin}${ext}`),\n\n      );\n\n      if (foundExt) return `${localBin}${foundExt}`;\n\n\n\n      return undefined;\n\n    }\n\n\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n\n    this._checkForMissingMandatoryOptions();\n\n    this._checkForConflictingOptions();\n\n\n\n    // executableFile and executableDir might be full path, or just a name\n\n    let executableFile =\n\n      subcommand._executableFile || `${this._name}-${subcommand._name}`;\n\n    let executableDir = this._executableDir || '';\n\n    if (this._scriptPath) {\n\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n\n      try {\n\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n\n      } catch (err) {\n\n        resolvedScriptPath = this._scriptPath;\n\n      }\n\n      executableDir = path.resolve(\n\n        path.dirname(resolvedScriptPath),\n\n        executableDir,\n\n      );\n\n    }\n\n\n\n    // Look for a local file in preference to a command in PATH.\n\n    if (executableDir) {\n\n      let localFile = findFile(executableDir, executableFile);\n\n\n\n      // Legacy search using prefix of script name instead of command name\n\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n\n        const legacyName = path.basename(\n\n          this._scriptPath,\n\n          path.extname(this._scriptPath),\n\n        );\n\n        if (legacyName !== this._name) {\n\n          localFile = findFile(\n\n            executableDir,\n\n            `${legacyName}-${subcommand._name}`,\n\n          );\n\n        }\n\n      }\n\n      executableFile = localFile || executableFile;\n\n    }\n\n\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n\n\n    let proc;\n\n    if (process.platform !== 'win32') {\n\n      if (launchWithNode) {\n\n        args.unshift(executableFile);\n\n        // add executable arguments to spawn\n\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n\n      } else {\n\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n\n      }\n\n    } else {\n\n      args.unshift(executableFile);\n\n      // add executable arguments to spawn\n\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n\n    }\n\n\n\n    if (!proc.killed) {\n\n      // testing mainly to avoid leak warnings during unit tests with mocked spawn\n\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n\n      signals.forEach((signal) => {\n\n        process.on(signal, () => {\n\n          if (proc.killed === false && proc.exitCode === null) {\n\n            // @ts-ignore because signals not typed to known strings\n\n            proc.kill(signal);\n\n          }\n\n        });\n\n      });\n\n    }\n\n\n\n    // By default terminate process when spawned process terminates.\n\n    const exitCallback = this._exitCallback;\n\n    proc.on('close', (code) => {\n\n      code = code ?? 1; // code is null if spawned process terminated due to a signal\n\n      if (!exitCallback) {\n\n        process.exit(code);\n\n      } else {\n\n        exitCallback(\n\n          new CommanderError(\n\n            code,\n\n            'commander.executeSubCommandAsync',\n\n            '(close)',\n\n          ),\n\n        );\n\n      }\n\n    });\n\n    proc.on('error', (err) => {\n\n      // @ts-ignore: because err.code is an unknown property\n\n      if (err.code === 'ENOENT') {\n\n        const executableDirMessage = executableDir\n\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n\n        const executableMissing = `'${executableFile}' does not exist\n\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n\n - ${executableDirMessage}`;\n\n        throw new Error(executableMissing);\n\n        // @ts-ignore: because err.code is an unknown property\n\n      } else if (err.code === 'EACCES') {\n\n        throw new Error(`'${executableFile}' not executable`);\n\n      }\n\n      if (!exitCallback) {\n\n        process.exit(1);\n\n      } else {\n\n        const wrappedError = new CommanderError(\n\n          1,\n\n          'commander.executeSubCommandAsync',\n\n          '(error)',\n\n        );\n\n        wrappedError.nestedError = err;\n\n        exitCallback(wrappedError);\n\n      }\n\n    });\n\n\n\n    // Store the reference to the child process\n\n    this.runningCommand = proc;\n\n  }\n",
    "line_range": [
        1101,
        1245
    ],
    "command_specific_fields": {
        "method_name": "_executeSubCommand"
    },
    "language": "javascript",
    "commit": "970ecae402b253de691e6a9066fea22f38fe7431",
    "prompt": ""
}