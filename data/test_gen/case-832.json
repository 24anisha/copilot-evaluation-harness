{
    "case_id": "case-832",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/utils/decorators.py",
    "code_snippet": "\n        Compute a Signature so that we can write a function wrapping f with\n        the same signature and call-type.\n\n        Parameters\n        ----------\n        f : callable\n            A function to be decorated\n\n        Returns\n        -------\n        sig : argmap.Signature\n            The Signature of f\n\n        Notes\n        -----\n        The Signature is a namedtuple with names:\n\n            name : a unique version of the name of the decorated function\n            signature : the inspect.signature of the decorated function\n            def_sig : a string used as code to define the new function\n            call_sig : a string used as code to call the decorated function\n            names : a dict keyed by argument name and index to the argument's name\n            n_positional : the number of positional arguments in the signature\n            args : the name of the VAR_POSITIONAL argument if any, i.e. \\*theseargs\n            kwargs : the name of the VAR_KEYWORDS argument if any, i.e. \\*\\*kwargs\n\n        These named attributes of the signature are used in `assemble` and `compile`\n        to construct a string of source code for the decorated function.\n\n        \"\"\"\n        sig = inspect.signature(f, follow_wrapped=False)\n        def_sig = []\n        call_sig = []\n        names = {}\n\n        kind = None\n        args = None\n        kwargs = None\n        npos = 0\n        for i, param in enumerate(sig.parameters.values()):\n            # parameters can be position-only, keyword-or-position, keyword-only\n            # in any combination, but only in the order as above.  we do edge\n            # detection to add the appropriate punctuation\n            prev = kind\n            kind = param.kind\n            if prev == param.POSITIONAL_ONLY != kind:\n                # the last token was position-only, but this one isn't\n                def_sig.append(\"/\")\n            if (\n                param.VAR_POSITIONAL\n                != prev\n                != param.KEYWORD_ONLY\n                == kind\n                != param.VAR_POSITIONAL\n            ):\n                # param is the first keyword-only arg and isn't starred\n                def_sig.append(\"*\")\n\n            # star arguments as appropriate\n            if kind == param.VAR_POSITIONAL:\n                name = \"*\" + param.name\n                args = param.name\n                count = 0\n            elif kind == param.VAR_KEYWORD:\n                name = \"**\" + param.name\n                kwargs = param.name\n                count = 0\n            else:\n                names[i] = names[param.name] = param.name\n                name = param.name\n                count = 1\n\n            # assign to keyword-only args in the function call\n            if kind == param.KEYWORD_ONLY:\n                call_sig.append(f\"{name} = {name}\")\n            else:\n                npos += count\n                call_sig.append(name)\n\n            def_sig.append(name)\n\n        fname = cls._name(f)\n        def_sig = f\"def {fname}({', '.join(def_sig)}):\"\n\n        call_sig = f\"return {{}}({', '.join(call_sig)})\"\n\n        return cls.Signature(fname, sig, def_sig, call_sig, names, npos, args, kwargs)\n\n    Signature = collections.namedtuple(\n        \"Signature\",\n        [\n            \"name\",\n",
    "line_range": [
        1062,
        1154
    ],
    "command_specific_fields": {
        "method_name": "signature"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}