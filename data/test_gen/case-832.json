{
    "case_id": "case-832",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/utils/decorators.py",
    "code_snippet": "        return sig, wrapped_name, functions, mapblock, finallys, mutable_args\n\n\n\n    @classmethod\n\n    def signature(cls, f):\n\n        r\"\"\"Construct a Signature object describing `f`\n\n\n\n        Compute a Signature so that we can write a function wrapping f with\n\n        the same signature and call-type.\n\n\n\n        Parameters\n\n        ----------\n\n        f : callable\n\n            A function to be decorated\n\n\n\n        Returns\n\n        -------\n\n        sig : argmap.Signature\n\n            The Signature of f\n\n\n\n        Notes\n\n        -----\n\n        The Signature is a namedtuple with names:\n\n\n\n            name : a unique version of the name of the decorated function\n\n            signature : the inspect.signature of the decorated function\n\n            def_sig : a string used as code to define the new function\n\n            call_sig : a string used as code to call the decorated function\n\n            names : a dict keyed by argument name and index to the argument's name\n\n            n_positional : the number of positional arguments in the signature\n\n            args : the name of the VAR_POSITIONAL argument if any, i.e. \\*theseargs\n\n            kwargs : the name of the VAR_KEYWORDS argument if any, i.e. \\*\\*kwargs\n\n\n\n        These named attributes of the signature are used in `assemble` and `compile`\n\n        to construct a string of source code for the decorated function.\n\n\n\n        \"\"\"\n\n        sig = inspect.signature(f, follow_wrapped=False)\n\n        def_sig = []\n\n        call_sig = []\n\n        names = {}\n\n\n\n        kind = None\n\n        args = None\n\n        kwargs = None\n\n        npos = 0\n\n        for i, param in enumerate(sig.parameters.values()):\n\n            # parameters can be position-only, keyword-or-position, keyword-only\n\n            # in any combination, but only in the order as above.  we do edge\n\n            # detection to add the appropriate punctuation\n\n            prev = kind\n\n            kind = param.kind\n\n            if prev == param.POSITIONAL_ONLY != kind:\n\n                # the last token was position-only, but this one isn't\n\n                def_sig.append(\"/\")\n\n            if (\n\n                param.VAR_POSITIONAL\n\n                != prev\n\n                != param.KEYWORD_ONLY\n\n                == kind\n\n                != param.VAR_POSITIONAL\n\n            ):\n\n                # param is the first keyword-only arg and isn't starred\n\n                def_sig.append(\"*\")\n\n\n\n            # star arguments as appropriate\n\n            if kind == param.VAR_POSITIONAL:\n\n                name = \"*\" + param.name\n\n                args = param.name\n\n                count = 0\n\n            elif kind == param.VAR_KEYWORD:\n\n                name = \"**\" + param.name\n\n                kwargs = param.name\n\n                count = 0\n\n            else:\n\n                names[i] = names[param.name] = param.name\n\n                name = param.name\n\n                count = 1\n\n\n\n            # assign to keyword-only args in the function call\n\n            if kind == param.KEYWORD_ONLY:\n\n                call_sig.append(f\"{name} = {name}\")\n\n            else:\n\n                npos += count\n\n                call_sig.append(name)\n\n\n\n            def_sig.append(name)\n\n\n\n        fname = cls._name(f)\n\n        def_sig = f'def {fname}({\", \".join(def_sig)}):'\n\n\n\n        call_sig = f\"return {{}}({', '.join(call_sig)})\"\n\n\n\n        return cls.Signature(fname, sig, def_sig, call_sig, names, npos, args, kwargs)\n",
    "line_range": [
        1062,
        1154
    ],
    "command_specific_fields": {
        "method_name": "signature"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}