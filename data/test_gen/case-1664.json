{
    "case_id": "case-1664",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/algorithms/components/biconnected.py",
    "code_snippet": "\n\n@not_implemented_for(\"directed\")\n@nx._dispatchable\ndef is_biconnected(G):\n    \"\"\"Returns True if the graph is biconnected, False otherwise.\n\n    A graph is biconnected if, and only if, it cannot be disconnected by\n    removing only one node (and all edges incident on that node).  If\n    removing a node increases the number of disconnected components\n    in the graph, that node is called an articulation point, or cut\n    vertex.  A biconnected graph has no articulation points.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    biconnected : bool\n        True if the graph is biconnected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> G.add_edge(0, 3)\n    >>> print(nx.is_biconnected(G))\n    True\n\n    See Also\n    --------\n    biconnected_components\n    articulation_points\n    biconnected_component_edges\n    is_strongly_connected\n    is_weakly_connected\n    is_connected\n    is_semiconnected\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\"\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        # No bicomponents (empty graph?)\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        # Only one bicomponent\n        return len(bcc) == len(G)\n    else:\n        # Multiple bicomponents\n        return False\n",
    "line_range": [
        14,
        94
    ],
    "command_specific_fields": {
        "method_name": "is_biconnected"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}