{
    "case_id": "case-620",
    "repo_name": "kelektiv/node-cron",
    "file_path": "src/job.ts",
    "code_snippet": "\t\tconst wasRunning = this._isActive;\n\t\tthis.stop();\n\n\t\tthis.cronTime = time;\n\t\tif (time.realDate) this.runOnce = true;\n\n\t\tif (wasRunning) this.start();\n\t}\n\n\tnextDate() {\n\t\treturn this.cronTime.sendAt();\n\t}\n\n\tasync fireOnTick() {\n\t\t// skip job if previous callback is still running\n\t\tif (this.waitForCompletion && this._isCallbackRunning) return;\n\n\t\tthis._isCallbackRunning = true;\n\n\t\ttry {\n\t\t\tfor (const callback of this._callbacks) {\n\t\t\t\tconst result = callback.call(\n\t\t\t\t\tthis.context,\n\t\t\t\t\tthis.onComplete as WithOnComplete<OC> extends true\n\t\t\t\t\t\t? CronOnCompleteCallback\n\t\t\t\t\t\t: never\n\t\t\t\t);\n\n\t\t\t\tif (this.waitForCompletion) await result;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (this.errorHandler != null) this.errorHandler(error);\n\t\t\telse console.error('[Cron] error in callback', error);\n\t\t} finally {\n\t\t\tthis._isCallbackRunning = false;\n\t\t}\n\t}\n\n\tnextDates(i?: number) {\n\t\treturn this.cronTime.sendAt(i ?? 0);\n\t}\n\n\tstart() {\n\t\tif (this._isActive) return;\n\n\t\tconst MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n\t\tlet timeout = this.cronTime.getTimeout();\n\t\tlet remaining = 0;\n\t\tlet startTime: number;\n\n\t\tconst setCronTimeout = (t: number) => {\n\t\t\tstartTime = Date.now();\n\t\t\tthis._timeout = setTimeout(callbackWrapper, t);\n\t\t\tif (this.unrefTimeout && typeof this._timeout.unref === 'function') {\n\t\t\t\tthis._timeout.unref();\n\t\t\t}\n\t\t};\n\n\t\t// The callback wrapper checks if it needs to sleep another period or not\n\t\t// and does the real callback logic when it's time.\n\t\tconst callbackWrapper = () => {\n\t\t\tconst diff = startTime + timeout - Date.now();\n\n\t\t\tif (diff > 0) {\n\t\t\t\tlet newTimeout = this.cronTime.getTimeout();\n\n\t\t\t\tif (newTimeout > diff) {\n\t\t\t\t\tnewTimeout = diff;\n\t\t\t\t}\n\n\t\t\t\tremaining += newTimeout;\n\t\t\t}\n\n\t\t\t// If there is sleep time remaining, calculate how long and go to sleep\n\t\t\t// again. This processing might make us miss the deadline by a few ms\n\t\t\t// times the number of sleep sessions. Given a MAXDELAY of almost a\n\t\t\t// month, this should be no issue.\n\t\t\tif (remaining) {\n\t\t\t\tif (remaining > MAXDELAY) {\n",
    "line_range": [
        209,
        287
    ],
    "command_specific_fields": {
        "method_name": "start"
    },
    "language": "typescript",
    "commit": "1eb978b8cddf8a2f2bead841adcad408238333c6",
    "prompt": ""
}