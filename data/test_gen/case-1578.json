{
    "case_id": "case-1578",
    "repo_name": "darknessomi/musicbox",
    "file_path": "NEMbox/api.py",
    "code_snippet": "            return {}\n\n\n\n    def dig_info(self, data, dig_type):\n\n        if not data:\n\n            return []\n\n        if dig_type == \"songs\" or dig_type == \"fmsongs\" or dig_type == \"djprograms\":\n\n            sids = [x[\"id\"] for x in data]\n\n            # \u53ef\u80fd\u56e0\u7f51\u7edc\u6ce2\u52a8\uff0c\u8fd4\u56de\u7a7a\u503c\uff0c\u5728Parse.songs\u4e2d\u5f15\u53d1KeyError\n\n            # \u5bfc\u81f4\u65e5\u5fd7\u8bb0\u5f55\u5927\u91cfcan't get song url\u7684\u53ef\u80fd\u539f\u56e0\n\n            urls = []\n\n            for i in range(0, len(sids), 350):\n\n                urls.extend(self.songs_url(sids[i : i + 350]))\n\n            # songs_detail api\u4f1a\u8fd4\u56de\u7a7a\u7684\u7535\u53f0\u6b4c\u540d\uff0c\u6545\u4f7f\u7528\u539f\u6570\u636e\n\n            sds = []\n\n            if dig_type == \"djprograms\":\n\n                sds.extend(data)\n\n            # \u652f\u6301\u8d85\u8fc71000\u9996\u6b4c\u66f2\u7684\u6b4c\u5355\n\n            else:\n\n                for i in range(0, len(sids), 500):\n\n                    sds.extend(self.songs_detail(sids[i : i + 500]))\n\n            # api \u8fd4\u56de\u7684 urls \u7684 id \u987a\u5e8f\u548c data \u7684 id \u987a\u5e8f\u4e0d\u4e00\u81f4\n\n            # \u4e3a\u4e86\u83b7\u53d6\u5230\u5bf9\u5e94 id \u7684 url\uff0c\u5bf9\u8fd4\u56de\u7684 urls \u505a\u4e00\u4e2a id2index \u7684\u7f13\u5b58\n\n            # \u540c\u65f6\u4fdd\u8bc1 data \u7684 id \u987a\u5e8f\u4e0d\u53d8\n\n            url_id_index = {}\n\n            for index, url in enumerate(urls):\n\n                url_id_index[url[\"id\"]] = index\n\n\n\n            timestamp = time.time()\n\n            for s in sds:\n\n                url_index = url_id_index.get(s[\"id\"])\n\n                if url_index is None:\n\n                    log.error(\"can't get song url, id: %s\", s[\"id\"])\n\n                    return []\n\n                s[\"url\"] = urls[url_index][\"url\"]\n\n                s[\"br\"] = urls[url_index][\"br\"]\n\n                s[\"expires\"] = urls[url_index][\"expi\"]\n\n                s[\"get_time\"] = timestamp\n\n            return Parse.songs(sds)\n\n\n\n        elif dig_type == \"refresh_urls\":\n\n            urls_info = []\n\n            for i in range(0, len(data), 350):\n\n                urls_info.extend(self.songs_url(data[i : i + 350]))\n\n            timestamp = time.time()\n\n\n\n            songs = []\n\n            for url_info in urls_info:\n\n                song = {}\n\n                song[\"song_id\"] = url_info[\"id\"]\n\n                song[\"mp3_url\"] = url_info[\"url\"]\n\n                song[\"expires\"] = url_info[\"expi\"]\n\n                song[\"get_time\"] = timestamp\n\n                songs.append(song)\n\n            return songs\n\n\n\n        elif dig_type == \"artists\":\n\n            return Parse.artists(data)\n\n\n\n        elif dig_type == \"albums\":\n\n            return Parse.albums(data)\n\n\n\n        elif dig_type == \"playlists\" or dig_type == \"top_playlists\":\n\n            return Parse.playlists(data)\n\n\n\n        elif dig_type == \"playlist_classes\":\n\n            return list(PLAYLIST_CLASSES.keys())\n\n\n\n        elif dig_type == \"playlist_class_detail\":\n\n            return PLAYLIST_CLASSES[data]\n\n\n\n        elif dig_type == \"djRadios\":\n\n            return data\n\n        else:\n\n            raise ValueError(\"Invalid dig type\")\n",
    "line_range": [
        566,
        639
    ],
    "command_specific_fields": {
        "method_name": "dig_info"
    },
    "language": "python",
    "commit": "592e13d1b948201447d008f4f3e249d347f47f21",
    "prompt": ""
}