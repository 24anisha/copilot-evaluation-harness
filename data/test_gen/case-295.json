{
    "case_id": "case-295",
    "repo_name": "foliojs/pdfkit",
    "file_path": "lib/line_wrapper.js",
    "code_snippet": "  }\n\n\n\n  wrap(text, options) {\n\n    // override options from previous continued fragments\n\n    if (options.indent != null) {\n\n      this.indent = options.indent;\n\n    }\n\n    if (options.characterSpacing != null) {\n\n      this.characterSpacing = options.characterSpacing;\n\n    }\n\n    if (options.wordSpacing != null) {\n\n      this.wordSpacing = options.wordSpacing;\n\n    }\n\n    if (options.ellipsis != null) {\n\n      this.ellipsis = options.ellipsis;\n\n    }\n\n\n\n    // make sure we're actually on the page\n\n    // and that the first line of is never by\n\n    // itself at the bottom of a page (orphans)\n\n    const nextY = this.document.y + this.document.currentLineHeight(true);\n\n    if (this.document.y > this.maxY || nextY > this.maxY) {\n\n      this.nextSection();\n\n    }\n\n\n\n    let buffer = '';\n\n    let textWidth = 0;\n\n    let wc = 0;\n\n    let lc = 0;\n\n\n\n    let { y } = this.document; // used to reset Y pos if options.continued (below)\n\n    const emitLine = () => {\n\n      options.textWidth = textWidth + this.wordSpacing * (wc - 1);\n\n      options.wordCount = wc;\n\n      options.lineWidth = this.lineWidth;\n\n      ({ y } = this.document);\n\n      this.emit('line', buffer, options, this);\n\n      return lc++;\n\n    };\n\n\n\n    this.emit('sectionStart', options, this);\n\n\n\n    this.eachWord(text, (word, w, bk, last) => {\n\n      if (last == null || last.required) {\n\n        this.emit('firstLine', options, this);\n\n        this.spaceLeft = this.lineWidth;\n\n      }\n\n\n\n      if (this.canFit(word, w)) {\n\n        buffer += word;\n\n        textWidth += w;\n\n        wc++;\n\n      }\n\n\n\n      if (bk.required || !this.canFit(word, w)) {\n\n        // if the user specified a max height and an ellipsis, and is about to pass the\n\n        // max height and max columns after the next line, append the ellipsis\n\n        const lh = this.document.currentLineHeight(true);\n\n        if (\n\n          this.height != null &&\n\n          this.ellipsis &&\n\n          this.document.y + lh * 2 > this.maxY &&\n\n          this.column >= this.columns\n\n        ) {\n\n          if (this.ellipsis === true) {\n\n            this.ellipsis = '\u2026';\n\n          } // map default ellipsis character\n\n          buffer = buffer.replace(/\\s+$/, '');\n\n          textWidth = this.wordWidth(buffer + this.ellipsis);\n\n\n\n          // remove characters from the buffer until the ellipsis fits\n\n          // to avoid infinite loop need to stop while-loop if buffer is empty string\n\n          while (buffer && textWidth > this.lineWidth) {\n\n            buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\n\n            textWidth = this.wordWidth(buffer + this.ellipsis);\n\n          }\n\n          // need to add ellipsis only if there is enough space for it\n\n          if (textWidth <= this.lineWidth) {\n\n            buffer = buffer + this.ellipsis;\n\n          }\n\n\n\n          textWidth = this.wordWidth(buffer);\n\n        }\n\n\n\n        if (bk.required) {\n\n          if (w > this.spaceLeft) {\n\n            emitLine();\n\n            buffer = word;\n\n            textWidth = w;\n\n            wc = 1;\n\n          }\n\n\n\n          this.emit('lastLine', options, this);\n\n        }\n\n\n\n        // Previous entry is a soft hyphen - add visible hyphen.\n\n        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {\n\n          buffer = buffer.slice(0, -1) + HYPHEN;\n\n          this.spaceLeft -= this.wordWidth(HYPHEN);\n\n        }\n\n\n\n        emitLine();\n\n\n\n        // if we've reached the edge of the page,\n\n        // continue on a new page or column\n\n        if (this.document.y + lh > this.maxY) {\n\n          const shouldContinue = this.nextSection();\n\n\n\n          // stop if we reached the maximum height\n\n          if (!shouldContinue) {\n\n            wc = 0;\n\n            buffer = '';\n\n            return false;\n\n          }\n\n        }\n\n\n\n        // reset the space left and buffer\n\n        if (bk.required) {\n\n          this.spaceLeft = this.lineWidth;\n\n          buffer = '';\n\n          textWidth = 0;\n\n          return (wc = 0);\n\n        } else {\n\n          // reset the space left and buffer\n\n          this.spaceLeft = this.lineWidth - w;\n\n          buffer = word;\n\n          textWidth = w;\n\n          return (wc = 1);\n\n        }\n\n      } else {\n\n        return (this.spaceLeft -= w);\n\n      }\n\n    });\n\n\n\n    if (wc > 0) {\n\n      this.emit('lastLine', options, this);\n\n      emitLine();\n\n    }\n\n\n\n    this.emit('sectionEnd', options, this);\n\n\n\n    // if the wrap is set to be continued, save the X position\n\n    // to start the first line of the next segment at, and reset\n\n    // the y position\n\n    if (options.continued === true) {\n\n      if (lc > 1) {\n\n        this.continuedX = 0;\n\n      }\n\n      this.continuedX += options.textWidth || 0;\n\n      return (this.document.y = y);\n\n    } else {\n\n      return (this.document.x = this.startX);\n\n    }\n\n  }\n",
    "line_range": [
        164,
        317
    ],
    "command_specific_fields": {
        "method_name": "wrap"
    },
    "language": "javascript",
    "commit": "9e5dfcdc0aa2424e1f98b3f88d229faf1ea31c49",
    "prompt": ""
}