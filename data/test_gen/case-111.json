{
    "case_id": "case-111",
    "repo_name": "jaredhanson/passport",
    "file_path": "lib/middleware/authenticate.js",
    "code_snippet": " * @api public\n\n */\n\nmodule.exports = function authenticate(passport, name, options, callback) {\n\n  if (typeof options == 'function') {\n\n    callback = options;\n\n    options = {};\n\n  }\n\n  options = options || {};\n\n  \n\n  var multi = true;\n\n  \n\n  // Cast `name` to an array, allowing authentication to pass through a chain of\n\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n\n  // the chain.  Authentication failures will proceed through each strategy in\n\n  // series, ultimately failing if all strategies fail.\n\n  //\n\n  // This is typically used on API endpoints to allow clients to authenticate\n\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n\n  // It is not feasible to construct a chain of multiple strategies that involve\n\n  // redirection (for example both Facebook and Twitter), since the first one to\n\n  // redirect will halt the chain.\n\n  if (!Array.isArray(name)) {\n\n    name = [ name ];\n\n    multi = false;\n\n  }\n\n  \n\n  return function authenticate(req, res, next) {\n\n    req.login =\n\n    req.logIn = req.logIn || IncomingMessageExt.logIn;\n\n    req.logout =\n\n    req.logOut = req.logOut || IncomingMessageExt.logOut;\n\n    req.isAuthenticated = req.isAuthenticated || IncomingMessageExt.isAuthenticated;\n\n    req.isUnauthenticated = req.isUnauthenticated || IncomingMessageExt.isUnauthenticated;\n\n    \n\n    req._sessionManager = passport._sm;\n\n    \n\n    // accumulator for failures from each strategy in the chain\n\n    var failures = [];\n\n    \n\n    function allFailed() {\n\n      if (callback) {\n\n        if (!multi) {\n\n          return callback(null, false, failures[0].challenge, failures[0].status);\n\n        } else {\n\n          var challenges = failures.map(function(f) { return f.challenge; });\n\n          var statuses = failures.map(function(f) { return f.status; });\n\n          return callback(null, false, challenges, statuses);\n\n        }\n\n      }\n\n      \n\n      // Strategies are ordered by priority.  For the purpose of flashing a\n\n      // message, the first failure will be displayed.\n\n      var failure = failures[0] || {}\n\n        , challenge = failure.challenge || {}\n\n        , msg;\n\n    \n\n      if (options.failureFlash) {\n\n        var flash = options.failureFlash;\n\n        if (typeof flash == 'string') {\n\n          flash = { type: 'error', message: flash };\n\n        }\n\n        flash.type = flash.type || 'error';\n\n      \n\n        var type = flash.type || challenge.type || 'error';\n\n        msg = flash.message || challenge.message || challenge;\n\n        if (typeof msg == 'string') {\n\n          req.flash(type, msg);\n\n        }\n\n      }\n\n      if (options.failureMessage) {\n\n        msg = options.failureMessage;\n\n        if (typeof msg == 'boolean') {\n\n          msg = challenge.message || challenge;\n\n        }\n\n        if (typeof msg == 'string') {\n\n          req.session.messages = req.session.messages || [];\n\n          req.session.messages.push(msg);\n\n        }\n\n      }\n\n      if (options.failureRedirect) {\n\n        return res.redirect(options.failureRedirect);\n\n      }\n\n    \n\n      // When failure handling is not delegated to the application, the default\n\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n\n      // header will be set according to the strategies in use (see\n\n      // actions#fail).  If multiple strategies failed, each of their challenges\n\n      // will be included in the response.\n\n      var rchallenge = []\n\n        , rstatus, status;\n\n      \n\n      for (var j = 0, len = failures.length; j < len; j++) {\n\n        failure = failures[j];\n\n        challenge = failure.challenge;\n\n        status = failure.status;\n\n          \n\n        rstatus = rstatus || status;\n\n        if (typeof challenge == 'string') {\n\n          rchallenge.push(challenge);\n\n        }\n\n      }\n\n    \n\n      res.statusCode = rstatus || 401;\n\n      if (res.statusCode == 401 && rchallenge.length) {\n\n        res.setHeader('WWW-Authenticate', rchallenge);\n\n      }\n\n      if (options.failWithError) {\n\n        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));\n\n      }\n\n      res.end(http.STATUS_CODES[res.statusCode]);\n\n    }\n\n    \n\n    (function attempt(i) {\n\n      var layer = name[i];\n\n      // If no more strategies exist in the chain, authentication has failed.\n\n      if (!layer) { return allFailed(); }\n\n    \n\n      // Get the strategy, which will be used as prototype from which to create\n\n      // a new instance.  Action functions will then be bound to the strategy\n\n      // within the context of the HTTP request/response pair.\n\n      var strategy, prototype;\n\n      if (typeof layer.authenticate == 'function') {\n\n        strategy = layer;\n\n      } else {\n\n        prototype = passport._strategy(layer);\n\n        if (!prototype) { return next(new Error('Unknown authentication strategy \"' + layer + '\"')); }\n\n        \n\n        strategy = Object.create(prototype);\n\n      }\n\n      \n\n      \n\n      // ----- BEGIN STRATEGY AUGMENTATION -----\n\n      // Augment the new strategy instance with action functions.  These action\n\n      // functions are bound via closure the the request/response pair.  The end\n\n      // goal of the strategy is to invoke *one* of these action methods, in\n\n      // order to indicate successful or failed authentication, redirect to a\n\n      // third-party identity provider, etc.\n\n      \n\n      /**\n\n       * Authenticate `user`, with optional `info`.\n\n       *\n\n       * Strategies should call this function to successfully authenticate a\n\n       * user.  `user` should be an object supplied by the application after it\n\n       * has been given an opportunity to verify credentials.  `info` is an\n\n       * optional argument containing additional user information.  This is\n\n       * useful for third-party authentication strategies to pass profile\n\n       * details.\n\n       *\n\n       * @param {Object} user\n\n       * @param {Object} info\n\n       * @api public\n\n       */\n\n      strategy.success = function(user, info) {\n\n        if (callback) {\n\n          return callback(null, user, info);\n\n        }\n\n      \n\n        info = info || {};\n\n        var msg;\n\n      \n\n        if (options.successFlash) {\n\n          var flash = options.successFlash;\n\n          if (typeof flash == 'string') {\n\n            flash = { type: 'success', message: flash };\n\n          }\n\n          flash.type = flash.type || 'success';\n\n        \n\n          var type = flash.type || info.type || 'success';\n\n          msg = flash.message || info.message || info;\n\n          if (typeof msg == 'string') {\n\n            req.flash(type, msg);\n\n          }\n\n        }\n\n        if (options.successMessage) {\n\n          msg = options.successMessage;\n\n          if (typeof msg == 'boolean') {\n\n            msg = info.message || info;\n\n          }\n\n          if (typeof msg == 'string') {\n\n            req.session.messages = req.session.messages || [];\n\n            req.session.messages.push(msg);\n\n          }\n\n        }\n\n        if (options.assignProperty) {\n\n          req[options.assignProperty] = user;\n\n          if (options.authInfo !== false) {\n\n            passport.transformAuthInfo(info, req, function(err, tinfo) {\n\n              if (err) { return next(err); }\n\n              req.authInfo = tinfo;\n\n              next();\n\n            });\n\n          } else {\n\n            next();\n\n          }\n\n          return;\n\n        }\n\n      \n\n        req.logIn(user, options, function(err) {\n\n          if (err) { return next(err); }\n\n          \n\n          function complete() {\n\n            if (options.successReturnToOrRedirect) {\n\n              var url = options.successReturnToOrRedirect;\n\n              if (req.session && req.session.returnTo) {\n\n                url = req.session.returnTo;\n\n                delete req.session.returnTo;\n\n              }\n\n              return res.redirect(url);\n\n            }\n\n            if (options.successRedirect) {\n\n              return res.redirect(options.successRedirect);\n\n            }\n\n            next();\n\n          }\n\n          \n\n          if (options.authInfo !== false) {\n\n            passport.transformAuthInfo(info, req, function(err, tinfo) {\n\n              if (err) { return next(err); }\n\n              req.authInfo = tinfo;\n\n              complete();\n\n            });\n\n          } else {\n\n            complete();\n\n          }\n\n        });\n\n      };\n\n      \n\n      /**\n\n       * Fail authentication, with optional `challenge` and `status`, defaulting\n\n       * to 401.\n\n       *\n\n       * Strategies should call this function to fail an authentication attempt.\n\n       *\n\n       * @param {String} challenge\n\n       * @param {Number} status\n\n       * @api public\n\n       */\n\n      strategy.fail = function(challenge, status) {\n\n        if (typeof challenge == 'number') {\n\n          status = challenge;\n\n          challenge = undefined;\n\n        }\n\n        \n\n        // push this failure into the accumulator and attempt authentication\n\n        // using the next strategy\n\n        failures.push({ challenge: challenge, status: status });\n\n        attempt(i + 1);\n\n      };\n\n      \n\n      /**\n\n       * Redirect to `url` with optional `status`, defaulting to 302.\n\n       *\n\n       * Strategies should call this function to redirect the user (via their\n\n       * user agent) to a third-party website for authentication.\n\n       *\n\n       * @param {String} url\n\n       * @param {Number} status\n\n       * @api public\n\n       */\n\n      strategy.redirect = function(url, status) {\n\n        // NOTE: Do not use `res.redirect` from Express, because it can't decide\n\n        //       what it wants.\n\n        //\n\n        //       Express 2.x: res.redirect(url, status)\n\n        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)\n\n        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)\n\n        //           is used\n\n        //       Express 4.x: res.redirect(status, url)\n\n        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)\n\n        //           but issue deprecated versions\n\n        \n\n        res.statusCode = status || 302;\n\n        res.setHeader('Location', url);\n\n        res.setHeader('Content-Length', '0');\n\n        res.end();\n\n      };\n\n      \n\n      /**\n\n       * Pass without making a success or fail decision.\n\n       *\n\n       * Under most circumstances, Strategies should not need to call this\n\n       * function.  It exists primarily to allow previous authentication state\n\n       * to be restored, for example from an HTTP session.\n\n       *\n\n       * @api public\n\n       */\n\n      strategy.pass = function() {\n\n        next();\n\n      };\n\n      \n\n      /**\n\n       * Internal error while performing authentication.\n\n       *\n\n       * Strategies should call this function when an internal error occurs\n\n       * during the process of performing authentication; for example, if the\n\n       * user directory is not available.\n\n       *\n\n       * @param {Error} err\n\n       * @api public\n\n       */\n\n      strategy.error = function(err) {\n\n        if (callback) {\n\n          return callback(err);\n\n        }\n\n        \n\n        next(err);\n\n      };\n\n      \n\n      // ----- END STRATEGY AUGMENTATION -----\n\n    \n\n      strategy.authenticate(req, options);\n\n    })(0); // attempt\n\n  };\n\n};\n",
    "line_range": [
        68,
        381
    ],
    "command_specific_fields": {
        "method_name": "authenticate"
    },
    "language": "javascript",
    "commit": "0575de90dc0e76c1b8ca9cc676af89bd301aec60",
    "prompt": ""
}