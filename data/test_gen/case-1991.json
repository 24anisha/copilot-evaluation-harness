{
    "case_id": "case-1991",
    "repo_name": "stefanprodan/AspNetCoreRateLimit",
    "file_path": "src/AspNetCoreRateLimit/Core/WildcardMatcher.cs",
    "code_snippet": "        {\n\n            var inputPosStack = new int[(value.Length + 1) * (pattern.Length + 1)];   // Stack containing input positions that should be tested for further matching\n            var patternPosStack = new int[inputPosStack.Length];                      // Stack containing pattern positions that should be tested for further matching\n            var stackPos = -1;                                                          // Points to last occupied entry in stack; -1 indicates that stack is empty\n            var pointTested = new bool[value.Length + 1, pattern.Length + 1];       // Each true value indicates that input position vs. pattern position has been tested\n\n            var inputPos = 0;   // Position in input matched up to the first multiple wildcard in pattern\n            var patternPos = 0; // Position in pattern matched up to the first multiple wildcard in pattern\n\n            //if (pattern == null)\n            //    pattern = string.Empty;\n\n            // Match beginning of the string until first multiple wildcard in pattern\n            while (inputPos < value.Length && patternPos < pattern.Length && pattern[patternPos] != multipleWildcard && (value[inputPos] == pattern[patternPos] || pattern[patternPos] == singleWildcard))\n            {\n                inputPos++;\n                patternPos++;\n            }\n\n            // Push this position to stack if it points to end of pattern or to a general wildcard character\n            if (patternPos == pattern.Length || pattern[patternPos] == multipleWildcard)\n            {\n                pointTested[inputPos, patternPos] = true;\n                inputPosStack[++stackPos] = inputPos;\n                patternPosStack[stackPos] = patternPos;\n            }\n\n            var matched = false;\n\n            // Repeat matching until either string is matched against the pattern or no more parts remain on stack to test\n            while (stackPos >= 0 && !matched)\n            {\n                inputPos = inputPosStack[stackPos];         // Pop input and pattern positions from stack\n                patternPos = patternPosStack[stackPos--];   // Matching will succeed if rest of the input string matches rest of the pattern\n\n                if (inputPos == value.Length && patternPos == pattern.Length)\n                    matched = true;     // Reached end of both pattern and input string, hence matching is successful\n                else if (patternPos == pattern.Length - 1)\n                    matched = true;     // Current pattern character is multiple wildcard and it will match all the remaining characters in the input string\n                else\n                {\n                    // First character in next pattern block is guaranteed to be multiple wildcard\n                    // So skip it and search for all matches in value string until next multiple wildcard character is reached in pattern\n\n                    for (var curInputStart = inputPos; curInputStart < value.Length; curInputStart++)\n                    {\n\n                        var curInputPos = curInputStart;\n                        var curPatternPos = patternPos + 1;\n\n                        while (curInputPos < value.Length && curPatternPos < pattern.Length && pattern[curPatternPos] != multipleWildcard &&\n                               (value[curInputPos] == pattern[curPatternPos] || pattern[curPatternPos] == singleWildcard))\n                        {\n                            curInputPos++;\n                            curPatternPos++;\n                        }\n\n                        // If we have reached next multiple wildcard character in pattern without breaking the matching sequence, then we have another candidate for full match\n                        // This candidate should be pushed to stack for further processing\n                        // At the same time, pair (input position, pattern position) will be marked as tested, so that it will not be pushed to stack later again\n                        if (((curPatternPos == pattern.Length && curInputPos == value.Length) || (curPatternPos < pattern.Length && pattern[curPatternPos] == multipleWildcard))\n                            && !pointTested[curInputPos, curPatternPos])\n                        {\n                            pointTested[curInputPos, curPatternPos] = true;\n                            inputPosStack[++stackPos] = curInputPos;\n                            patternPosStack[stackPos] = curPatternPos;\n                        }\n                    }\n                }\n            }\n\n            return matched;\n        }",
    "line_range": [
        6,
        82
    ],
    "command_specific_fields": {
        "method_name": "IsMatch"
    },
    "language": "csharp",
    "commit": "3a574a8e6a6ab1bfe3ecf285490568c08cf1aa65",
    "prompt": ""
}