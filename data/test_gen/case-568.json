{
    "case_id": "case-568",
    "repo_name": "cheeriojs/cheerio",
    "file_path": "src/load.ts",
    "code_snippet": "\n\nexport function getLoad(\n\n  parse: typeof Cheerio.prototype._parse,\n\n  render: (\n\n    dom: AnyNode | ArrayLike<AnyNode>,\n\n    options: InternalOptions,\n\n  ) => string,\n\n) {\n\n  /**\n\n   * Create a querying function, bound to a document created from the provided\n\n   * markup.\n\n   *\n\n   * Note that similar to web browser contexts, this operation may introduce\n\n   * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to\n\n   * switch to fragment mode and disable this.\n\n   *\n\n   * @param content - Markup to be loaded.\n\n   * @param options - Options for the created instance.\n\n   * @param isDocument - Allows parser to be switched to fragment mode.\n\n   * @returns The loaded document.\n\n   * @see {@link https://cheerio.js.org#loading} for additional usage information.\n\n   */\n\n  return function load(\n\n    content: string | AnyNode | AnyNode[] | Buffer,\n\n    options?: CheerioOptions | null,\n\n    isDocument = true,\n\n  ): CheerioAPI {\n\n    if ((content as string | null) == null) {\n\n      throw new Error('cheerio.load() expects a string');\n\n    }\n\n\n\n    const internalOpts = flattenOptions(options);\n\n    const initialRoot = parse(content, internalOpts, isDocument, null);\n\n\n\n    /**\n\n     * Create an extended class here, so that extensions only live on one\n\n     * instance.\n\n     */\n\n    class LoadedCheerio<T> extends Cheerio<T> {\n\n      _make<T>(\n\n        selector?: ArrayLike<T> | T | string,\n\n        context?: BasicAcceptedElems<AnyNode> | null,\n\n      ): Cheerio<T> {\n\n        const cheerio = initialize(selector, context);\n\n        cheerio.prevObject = this;\n\n\n\n        return cheerio;\n\n      }\n\n\n\n      _parse(\n\n        content: string | Document | AnyNode | AnyNode[] | Buffer,\n\n        options: InternalOptions,\n\n        isDocument: boolean,\n\n        context: ParentNode | null,\n\n      ) {\n\n        return parse(content, options, isDocument, context);\n\n      }\n\n\n\n      _render(dom: AnyNode | ArrayLike<AnyNode>): string {\n\n        return render(dom, this.options);\n\n      }\n\n    }\n\n\n\n    function initialize<T = AnyNode, S extends string = string>(\n\n      selector?: ArrayLike<T> | T | S,\n\n      context?: BasicAcceptedElems<AnyNode> | null,\n\n      root: BasicAcceptedElems<Document> = initialRoot,\n\n      opts?: CheerioOptions,\n\n    ): Cheerio<S extends SelectorType ? Element : T> {\n\n      type Result = S extends SelectorType ? Element : T;\n\n\n\n      // $($)\n\n      if (selector && isCheerio<Result>(selector)) return selector;\n\n\n\n      const options = flattenOptions(opts, internalOpts);\n\n      const r =\n\n        typeof root === 'string'\n\n          ? [parse(root, options, false, null)]\n\n          : 'length' in root\n\n            ? root\n\n            : [root];\n\n      const rootInstance = isCheerio<Document>(r)\n\n        ? r\n\n        : new LoadedCheerio<Document>(r, null, options);\n\n      // Add a cyclic reference, so that calling methods on `_root` never fails.\n\n      rootInstance._root = rootInstance;\n\n\n\n      // $(), $(null), $(undefined), $(false)\n\n      if (!selector) {\n\n        return new LoadedCheerio<Result>(undefined, rootInstance, options);\n\n      }\n\n\n\n      const elements: AnyNode[] | undefined =\n\n        typeof selector === 'string' && isHtml(selector)\n\n          ? // $(<html>)\n\n            parse(selector, options, false, null).children\n\n          : isNode(selector)\n\n            ? // $(dom)\n\n              [selector]\n\n            : Array.isArray(selector)\n\n              ? // $([dom])\n\n                selector\n\n              : undefined;\n\n\n\n      const instance = new LoadedCheerio(elements, rootInstance, options);\n\n\n\n      if (elements) {\n\n        return instance as any;\n\n      }\n\n\n\n      if (typeof selector !== 'string') {\n\n        throw new TypeError('Unexpected type of selector');\n\n      }\n\n\n\n      // We know that our selector is a string now.\n\n      let search = selector;\n\n\n\n      const searchContext: Cheerio<AnyNode> | undefined = context\n\n        ? // If we don't have a context, maybe we have a root, from loading\n\n          typeof context === 'string'\n\n          ? isHtml(context)\n\n            ? // $('li', '<ul>...</ul>')\n\n              new LoadedCheerio<Document>(\n\n                [parse(context, options, false, null)],\n\n                rootInstance,\n\n                options,\n\n              )\n\n            : // $('li', 'ul')\n\n              ((search = `${context} ${search}` as S), rootInstance)\n\n          : isCheerio<AnyNode>(context)\n\n            ? // $('li', $)\n\n              context\n\n            : // $('li', node), $('li', [nodes])\n\n              new LoadedCheerio<AnyNode>(\n\n                Array.isArray(context) ? context : [context],\n\n                rootInstance,\n\n                options,\n\n              )\n\n        : rootInstance;\n\n\n\n      // If we still don't have a context, return\n\n      if (!searchContext) return instance as any;\n\n\n\n      /*\n\n       * #id, .class, tag\n\n       */\n\n      return searchContext.find(search) as Cheerio<Result>;\n\n    }\n\n\n\n    // Add in static methods & properties\n\n    Object.assign(initialize, staticMethods, {\n\n      load,\n\n      // `_root` and `_options` are used in static methods.\n\n      _root: initialRoot,\n\n      _options: internalOpts,\n\n      // Add `fn` for plugins\n\n      fn: LoadedCheerio.prototype,\n\n      // Add the prototype here to maintain `instanceof` behavior.\n\n      prototype: LoadedCheerio.prototype,\n\n    });\n\n\n\n    return initialize as CheerioAPI;\n\n  };\n\n}\n",
    "line_range": [
        104,
        268
    ],
    "command_specific_fields": {
        "method_name": "getLoad"
    },
    "language": "typescript",
    "commit": "da0b8840f42489030da52172f08d79d4509c999b",
    "prompt": ""
}