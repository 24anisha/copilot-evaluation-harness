{
    "case_id": "case-586",
    "repo_name": "kelektiv/node-cron",
    "file_path": "src/time.ts",
    "code_snippet": "\n\t\t\t// hard stop if the current date is after the maximum match interval\n\t\t\tif (date > maxMatch) {\n\t\t\t\tthrow new CronError(\n\t\t\t\t\t`Something went wrong. No execution date was found in the next 8 years.\n\t\t\t\t\t\t\tPlease provide the following string if you would like to help debug:\n\t\t\t\t\t\t\tTime Zone: ${\n\t\t\t\t\t\t\t\ttimeZone?.toString() ?? '\"\"'\n\t\t\t\t\t\t\t} - Cron String: ${this.source.toString()} - UTC offset: ${\n\t\t\t\t\t\t\t\tdate.offset\n\t\t\t\t\t\t\t} - current Date: ${DateTime.local().toString()}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(date.month in this.month) &&\n\t\t\t\tObject.keys(this.month).length !== 12\n\t\t\t) {\n\t\t\t\tdate = date.plus({ months: 1 });\n\t\t\t\tdate = date.set({ day: 1, hour: 0, minute: 0, second: 0 });\n\n\t\t\t\tif (this._forwardDSTJump(0, 0, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(date.day in this.dayOfMonth) &&\n\t\t\t\tObject.keys(this.dayOfMonth).length !== 31 &&\n\t\t\t\t!(\n\t\t\t\t\tthis._getWeekDay(date) in this.dayOfWeek &&\n\t\t\t\t\tObject.keys(this.dayOfWeek).length !== 7\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tdate = date.plus({ days: 1 });\n\t\t\t\tdate = date.set({ hour: 0, minute: 0, second: 0 });\n\n\t\t\t\tif (this._forwardDSTJump(0, 0, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(this._getWeekDay(date) in this.dayOfWeek) &&\n\t\t\t\tObject.keys(this.dayOfWeek).length !== 7 &&\n\t\t\t\t!(\n\t\t\t\t\tdate.day in this.dayOfMonth &&\n\t\t\t\t\tObject.keys(this.dayOfMonth).length !== 31\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tdate = date.plus({ days: 1 });\n\t\t\t\tdate = date.set({ hour: 0, minute: 0, second: 0 });\n\t\t\t\tif (this._forwardDSTJump(0, 0, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.hour in this.hour) && Object.keys(this.hour).length !== 24) {\n\t\t\t\tconst expectedHour =\n\t\t\t\t\tdate.hour === 23 && diff > 86400000 ? 0 : date.hour + 1;\n\t\t\t\tconst expectedMinute = date.minute; // expect no change.\n\n\t\t\t\tdate = date.set({ hour: expectedHour });\n\t\t\t\tdate = date.set({ minute: 0, second: 0 });\n\n\t\t\t\t// When this is the case, Asking luxon to go forward by 1 hour actually made us go forward by more hours...\n\t\t\t\t// This indicates that somewhere between these two time points, a forward DST adjustment has happened.\n\t\t\t\t// When this happens, the job should be scheduled to execute as though the time has come when the jump is made.\n\t\t\t\t// Therefore, the job should be scheduled on the first tick after the forward jump.\n\t\t\t\tif (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\t\t\t\t// backwards jumps do not seem to have any problems (i.e. double activations),\n\t\t\t\t// so they need not be handled in a similar way.\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(date.minute in this.minute) &&\n\t\t\t\tObject.keys(this.minute).length !== 60\n\t\t\t) {\n\t\t\t\tconst expectedMinute =\n\t\t\t\t\tdate.minute === 59 && diff > 3600000 ? 0 : date.minute + 1;\n\t\t\t\tconst expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n\n\t\t\t\tdate = date.set({ minute: expectedMinute });\n\t\t\t\tdate = date.set({ second: 0 });\n\n\t\t\t\t// Same case as with hours: DST forward jump.\n\t\t\t\t// This must be accounted for if a minute increment pushed us to a jumping point.\n\t\t\t\tif (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(date.second in this.second) &&\n\t\t\t\tObject.keys(this.second).length !== 60\n\t\t\t) {\n\t\t\t\tconst expectedSecond =\n\t\t\t\t\tdate.second === 59 && diff > 60000 ? 0 : date.second + 1;\n\t\t\t\tconst expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n\t\t\t\tconst expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n\n\t\t\t\tdate = date.set({ second: expectedSecond });\n\n\t\t\t\t// Seconds can cause it too, imagine 21:59:59 -> 23:00:00.\n\t\t\t\tif (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (date.toMillis() === firstDate) {\n\t\t\t\tconst expectedSecond = date.second + 1;\n\t\t\t\tconst expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n\t\t\t\tconst expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n\n\t\t\t\tdate = date.set({ second: expectedSecond });\n\n\t\t\t\t// Same as always.\n\t\t\t\tif (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n\t\t\t\t\tconst [isDone, newDate] = this._findPreviousDSTJump(date);\n\t\t\t\t\tdate = newDate;\n\t\t\t\t\tif (isDone) break;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn date;\n\t}\n\n\t/**\n\t * Search backwards in time 1 minute at a time, to detect a DST forward jump.\n\t * When the jump is found, the range of the jump is investigated to check for acceptable cron times.\n\t *\n\t * A pair is returned, whose first is a boolean representing if an acceptable time was found inside the jump,\n\t * and whose second is a DateTime representing the first millisecond after the jump.\n\t *\n\t * The input date is expected to be decently close to a DST jump.\n\t * Up to a day in the past is checked before an error is thrown.\n\t * @param date\n\t * @return [boolean, DateTime]\n\t */\n\tprivate _findPreviousDSTJump(date: DateTime): [boolean, DateTime] {\n\t\t/** @type number */\n\t\tlet expectedMinute, expectedHour, actualMinute, actualHour;\n\t\t/** @type DateTime */\n\t\tlet maybeJumpingPoint = date;\n\n\t\t// representing one day of backwards checking. If this is hit, the input must be wrong.\n\t\tconst iterationLimit = 60 * 24;\n\t\tlet iteration = 0;\n\t\tdo {\n\t\t\tif (++iteration > iterationLimit) {\n\t\t\t\tthrow new CronError(\n\t\t\t\t\t`ERROR: This DST checking related function assumes the input DateTime (${\n\t\t\t\t\t\tdate.toISO() ?? date.toMillis()\n\t\t\t\t\t}) is within 24 hours of a DST jump.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\texpectedMinute = maybeJumpingPoint.minute - 1;\n\t\t\texpectedHour = maybeJumpingPoint.hour;\n",
    "line_range": [
        225,
        411
    ],
    "command_specific_fields": {
        "method_name": "getNextDateFrom"
    },
    "language": "typescript",
    "commit": "1eb978b8cddf8a2f2bead841adcad408238333c6",
    "prompt": ""
}