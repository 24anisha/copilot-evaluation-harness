{
    "case_id": "case-276",
    "repo_name": "fluent-ffmpeg/node-fluent-ffmpeg",
    "file_path": "lib/recipes.js",
    "code_snippet": "\n\nmodule.exports = function recipes(proto) {\n\n  /**\n\n   * Execute ffmpeg command and save output to a file\n\n   *\n\n   * @method FfmpegCommand#save\n\n   * @category Processing\n\n   * @aliases saveToFile\n\n   *\n\n   * @param {String} output file path\n\n   * @return FfmpegCommand\n\n   */\n\n  proto.saveToFile =\n\n  proto.save = function(output) {\n\n    this.output(output).run();\n\n    return this;\n\n  };\n\n\n\n\n\n  /**\n\n   * Execute ffmpeg command and save output to a stream\n\n   *\n\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n\n   * 'options' will be used when piping ffmpeg output to the output stream\n\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n\n   *\n\n   * @method FfmpegCommand#pipe\n\n   * @category Processing\n\n   * @aliases stream,writeToStream\n\n   *\n\n   * @param {stream.Writable} [stream] output stream\n\n   * @param {Object} [options={}] pipe options\n\n   * @return Output stream\n\n   */\n\n  proto.writeToStream =\n\n  proto.pipe =\n\n  proto.stream = function(stream, options) {\n\n    if (stream && !('writable' in stream)) {\n\n      options = stream;\n\n      stream = undefined;\n\n    }\n\n\n\n    if (!stream) {\n\n      if (process.version.match(/v0\\.8\\./)) {\n\n        throw new Error('PassThrough stream is not supported on node v0.8');\n\n      }\n\n\n\n      stream = new PassThrough();\n\n    }\n\n\n\n    this.output(stream, options).run();\n\n    return stream;\n\n  };\n\n\n\n\n\n  /**\n\n   * Generate images from a video\n\n   *\n\n   * Note: this method makes the command emit a 'filenames' event with an array of\n\n   * the generated image filenames.\n\n   *\n\n   * @method FfmpegCommand#screenshots\n\n   * @category Processing\n\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n\n   *\n\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n\n   *   the following keys:\n\n   * @param {Number} [config.count] number of screenshots to take; using this option\n\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n\n   *   60% and 80% of the video length).\n\n   * @param {String} [config.folder='.'] output folder\n\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n\n   *   tokens:\n\n   *   - '%s': offset in seconds\n\n   *   - '%w': screenshot width\n\n   *   - '%h': screenshot height\n\n   *   - '%r': screenshot resolution (same as '%wx%h')\n\n   *   - '%f': input filename\n\n   *   - '%b': input basename (filename w/o extension)\n\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n\n   *   'XX%' string.  Overrides 'count' if present.\n\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n\n   * @return FfmpegCommand\n\n   */\n\n  proto.takeScreenshots =\n\n  proto.thumbnail =\n\n  proto.thumbnails =\n\n  proto.screenshot =\n\n  proto.screenshots = function(config, folder) {\n\n    var self = this;\n\n    var source = this._currentInput.source;\n\n    config = config || { count: 1 };\n\n\n\n    // Accept a number of screenshots instead of a config object\n\n    if (typeof config === 'number') {\n\n      config = {\n\n        count: config\n\n      };\n\n    }\n\n\n\n    // Accept a second 'folder' parameter instead of config.folder\n\n    if (!('folder' in config)) {\n\n      config.folder = folder || '.';\n\n    }\n\n\n\n    // Accept 'timestamps' instead of 'timemarks'\n\n    if ('timestamps' in config) {\n\n      config.timemarks = config.timestamps;\n\n    }\n\n\n\n    // Compute timemarks from count if not present\n\n    if (!('timemarks' in config)) {\n\n      if (!config.count) {\n\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n\n      }\n\n\n\n      var interval = 100 / (1 + config.count);\n\n      config.timemarks = [];\n\n      for (var i = 0; i < config.count; i++) {\n\n        config.timemarks.push((interval * (i + 1)) + '%');\n\n      }\n\n    }\n\n\n\n    // Parse size option\n\n    if ('size' in config) {\n\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n\n        throw new Error('Invalid size parameter: ' + config.size);\n\n      }\n\n    }\n\n\n\n    // Metadata helper\n\n    var metadata;\n\n    function getMetadata(cb) {\n\n      if (metadata) {\n\n        cb(null, metadata);\n\n      } else {\n\n        self.ffprobe(function(err, meta) {\n\n          metadata = meta;\n\n          cb(err, meta);\n\n        });\n\n      }\n\n    }\n\n\n\n    async.waterfall([\n\n      // Compute percent timemarks if any\n\n      function computeTimemarks(next) {\n\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n\n          if (typeof source !== 'string') {\n\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n\n          }\n\n\n\n          getMetadata(function(err, meta) {\n\n            if (err) {\n\n              next(err);\n\n            } else {\n\n              // Select video stream with the highest resolution\n\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n\n                  return stream;\n\n                } else {\n\n                  return biggest;\n\n                }\n\n              }, { width: 0, height: 0 });\n\n\n\n              if (vstream.width === 0) {\n\n                return next(new Error('No video stream in input, cannot take screenshots'));\n\n              }\n\n\n\n              var duration = Number(vstream.duration);\n\n              if (isNaN(duration)) {\n\n                duration = Number(meta.format.duration);\n\n              }\n\n\n\n              if (isNaN(duration)) {\n\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n\n              }\n\n\n\n              config.timemarks = config.timemarks.map(function(mark) {\n\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n\n                  return duration * parseFloat(mark) / 100;\n\n                } else {\n\n                  return mark;\n\n                }\n\n              });\n\n\n\n              next();\n\n            }\n\n          });\n\n        } else {\n\n          next();\n\n        }\n\n      },\n\n\n\n      // Turn all timemarks into numbers and sort them\n\n      function normalizeTimemarks(next) {\n\n        config.timemarks = config.timemarks.map(function(mark) {\n\n          return utils.timemarkToSeconds(mark);\n\n        }).sort(function(a, b) { return a - b; });\n\n\n\n        next();\n\n      },\n\n\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n\n      function fixPattern(next) {\n\n        var pattern = config.filename || 'tn.png';\n\n\n\n        if (pattern.indexOf('.') === -1) {\n\n          pattern += '.png';\n\n        }\n\n\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n\n          var ext = path.extname(pattern);\n\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n\n        }\n\n\n\n        next(null, pattern);\n\n      },\n\n\n\n      // Replace filename tokens (%f, %b) in pattern\n\n      function replaceFilenameTokens(pattern, next) {\n\n        if (pattern.match(/%[bf]/)) {\n\n          if (typeof source !== 'string') {\n\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n\n          }\n\n\n\n          pattern = pattern\n\n            .replace(/%f/g, path.basename(source))\n\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n\n        }\n\n\n\n        next(null, pattern);\n\n      },\n\n\n\n      // Compute size if needed\n\n      function getSize(pattern, next) {\n\n        if (pattern.match(/%[whr]/)) {\n\n          if (fixedSize) {\n\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n\n          }\n\n\n\n          getMetadata(function(err, meta) {\n\n            if (err) {\n\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n\n            }\n\n\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n\n                return stream;\n\n              } else {\n\n                return biggest;\n\n              }\n\n            }, { width: 0, height: 0 });\n\n\n\n            if (vstream.width === 0) {\n\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n\n            }\n\n\n\n            var width = vstream.width;\n\n            var height = vstream.height;\n\n\n\n            if (fixedWidth) {\n\n              height = height * Number(fixedWidth[1]) / width;\n\n              width = Number(fixedWidth[1]);\n\n            } else if (fixedHeight) {\n\n              width = width * Number(fixedHeight[1]) / height;\n\n              height = Number(fixedHeight[1]);\n\n            } else if (percentSize) {\n\n              width = width * Number(percentSize[1]) / 100;\n\n              height = height * Number(percentSize[1]) / 100;\n\n            }\n\n\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n\n          });\n\n        } else {\n\n          next(null, pattern, -1, -1);\n\n        }\n\n      },\n\n\n\n      // Replace size tokens (%w, %h, %r) in pattern\n\n      function replaceSizeTokens(pattern, width, height, next) {\n\n        pattern = pattern\n\n          .replace(/%r/g, '%wx%h')\n\n          .replace(/%w/g, width)\n\n          .replace(/%h/g, height);\n\n\n\n        next(null, pattern);\n\n      },\n\n\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n\n      function replaceVariableTokens(pattern, next) {\n\n        var filenames = config.timemarks.map(function(t, i) {\n\n          return pattern\n\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n\n            .replace(/%(0*)i/g, function(match, padding) {\n\n              var idx = '' + (i + 1);\n\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n\n            });\n\n        });\n\n\n\n        self.emit('filenames', filenames);\n\n        next(null, filenames);\n\n      },\n\n\n\n      // Create output directory\n\n      function createDirectory(filenames, next) {\n\n        fs.exists(config.folder, function(exists) {\n\n          if (!exists) {\n\n            fs.mkdir(config.folder, function(err) {\n\n              if (err) {\n\n                next(err);\n\n              } else {\n\n                next(null, filenames);\n\n              }\n\n            });\n\n          } else {\n\n            next(null, filenames);\n\n          }\n\n        });\n\n      }\n\n    ], function runCommand(err, filenames) {\n\n      if (err) {\n\n        return self.emit('error', err);\n\n      }\n\n\n\n      var count = config.timemarks.length;\n\n      var split;\n\n      var filters = [split = {\n\n        filter: 'split',\n\n        options: count,\n\n        outputs: []\n\n      }];\n\n\n\n      if ('size' in config) {\n\n        // Set size to generate size filters\n\n        self.size(config.size);\n\n\n\n        // Get size filters and chain them with 'sizeN' stream names\n\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n\n          if (i > 0) {\n\n            f.inputs = 'size' + (i - 1);\n\n          }\n\n\n\n          f.outputs = 'size' + i;\n\n\n\n          return f;\n\n        });\n\n\n\n        // Input last size filter output into split filter\n\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n\n\n        // Add size filters in front of split filter\n\n        filters = sizeFilters.concat(filters);\n\n\n\n        // Remove size filters\n\n        self._currentOutput.sizeFilters.clear();\n\n      }\n\n\n\n      var first = 0;\n\n      for (var i = 0; i < count; i++) {\n\n        var stream = 'screen' + i;\n\n        split.outputs.push(stream);\n\n\n\n        if (i === 0) {\n\n          first = config.timemarks[i];\n\n          self.seekInput(first);\n\n        }\n\n\n\n        self.output(path.join(config.folder, filenames[i]))\n\n          .frames(1)\n\n          .map(stream);\n\n\n\n        if (i > 0) {\n\n          self.seek(config.timemarks[i] - first);\n\n        }\n\n      }\n\n\n\n      self.complexFilter(filters);\n\n      self.run();\n\n    });\n\n\n\n    return this;\n\n  };\n\n\n\n\n\n  /**\n\n   * Merge (concatenate) inputs to a single file\n\n   *\n\n   * @method FfmpegCommand#concat\n\n   * @category Processing\n\n   * @aliases concatenate,mergeToFile\n\n   *\n\n   * @param {String|Writable} target output file or writable stream\n\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n\n   * @return FfmpegCommand\n\n   */\n\n  proto.mergeToFile =\n\n  proto.concatenate =\n\n  proto.concat = function(target, options) {\n\n    // Find out which streams are present in the first non-stream input\n\n    var fileInput = this._inputs.filter(function(input) {\n\n      return !input.isStream;\n\n    })[0];\n\n\n\n    var self = this;\n\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n\n      if (err) {\n\n        return self.emit('error', err);\n\n      }\n\n\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n\n        return stream.codec_type === 'audio';\n\n      });\n\n\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n\n        return stream.codec_type === 'video';\n\n      });\n\n\n\n      // Setup concat filter and start processing\n\n      self.output(target, options)\n\n        .complexFilter({\n\n          filter: 'concat',\n\n          options: {\n\n            n: self._inputs.length,\n\n            v: hasVideoStreams ? 1 : 0,\n\n            a: hasAudioStreams ? 1 : 0\n\n          }\n\n        })\n\n        .run();\n\n    });\n\n\n\n    return this;\n\n  };\n\n};\n",
    "line_range": [
        13,
        456
    ],
    "command_specific_fields": {
        "method_name": "recipes"
    },
    "language": "javascript",
    "commit": "fafb8d3a66f91485907145d776cc14272e402f48",
    "prompt": ""
}