{
    "case_id": "case-1144",
    "repo_name": "trekhleb/learn-python",
    "file_path": "src/functions/test_function_definition.py",
    "code_snippet": "\n\ndef fibonacci_function_example(number_limit):\n\n    \"\"\"Generate a Fibonacci series up to number_limit.\n\n\n\n    The first statement of the function body can optionally be a string literal; this string\n\n    literal is the function\u2019s documentation string, or docstring. There are tools which use\n\n    docstrings to automatically produce online or printed documentation, or to let the user\n\n    interactively browse through code; it\u2019s good practice to include docstrings in code that you\n\n    write, so make a habit of it.\n\n    \"\"\"\n\n\n\n    # The execution of a function introduces a new symbol table used for the local variables of the\n\n    # function. More precisely, all variable assignments in a function store the value in the local\n\n    # symbol table; whereas variable references first look in the local symbol table, then in the\n\n    # local symbol tables of enclosing functions, then in the global symbol table, and finally in\n\n    # the table of built-in names. Thus, global variables cannot be directly assigned a value\n\n    # within a function (unless named in a global statement), although they may be referenced.\n\n    fibonacci_list = []\n\n    previous_number, current_number = 0, 1\n\n    while previous_number < number_limit:\n\n        # The statement result.append(a) calls a method of the list object result. A method is a\n\n        # function that \u2018belongs\u2019 to an object and is named obj.methodname, where obj is some\n\n        # object (this may be an expression), and methodname is the name of a method that is\n\n        # defined by the object\u2019s type. Different types define different methods. Methods of\n\n        # different types may have the same name without causing ambiguity. (It is possible to\n\n        # define your own object types and methods, using classes, see Classes) The method\n\n        # append() shown in the example is defined for list objects; it adds a new element at\n\n        # the end of the list. In this example it is equivalent to result = result + [a], but\n\n        # more efficient.\n\n        fibonacci_list.append(previous_number)\n\n        # This is multiple assignment statement. We make current number to be previous one and the\n\n        # sum of previous and current to be a new current.\n\n        previous_number, current_number = current_number, previous_number + current_number\n\n\n\n    # The return statement returns with a value from a function. return without an expression\n\n    # argument returns None. Falling off the end of a function also returns None.\n\n    return fibonacci_list\n",
    "line_range": [
        10,
        47
    ],
    "command_specific_fields": {
        "method_name": "fibonacci_function_example"
    },
    "language": "python",
    "commit": "52c3a655cc2efd5ac01004f6f529c3262812a84e",
    "prompt": ""
}