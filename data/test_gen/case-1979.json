{
    "case_id": "case-1979",
    "repo_name": "stefanprodan/AspNetCoreRateLimit",
    "file_path": "src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs",
    "code_snippet": "        {\n            // check if rate limiting is enabled\n            if (_options == null)\n            {\n                await _next.Invoke(context);\n                return;\n            }\n\n            // compute identity from request\n            var identity = await ResolveIdentityAsync(context);\n\n            // check white list\n            if (_processor.IsWhitelisted(identity))\n            {\n                await _next.Invoke(context);\n                return;\n            }\n\n            var rules = await _processor.GetMatchingRulesAsync(identity, context.RequestAborted);\n\n            var rulesDict = new Dictionary<RateLimitRule, RateLimitCounter>();\n\n            foreach (var rule in rules)\n            {\n                // increment counter\n                var rateLimitCounter = await _processor.ProcessRequestAsync(identity, rule, context.RequestAborted);\n\n                if (rule.Limit > 0)\n                {\n                    // check if key expired\n                    if (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value < DateTime.UtcNow)\n                    {\n                        continue;\n                    }\n\n                    // check if limit is reached\n                    if (rateLimitCounter.Count > rule.Limit)\n                    {\n                        //compute retry after value\n                        var retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);\n\n                        // log blocked request\n                        LogBlockedRequest(context, identity, rateLimitCounter, rule);\n\n                        if (_options.RequestBlockedBehaviorAsync != null)\n                        {\n                            await _options.RequestBlockedBehaviorAsync(context, identity, rateLimitCounter, rule);\n                        }\n\n                        if (!rule.MonitorMode)\n                        {\n                            // break execution\n                            await ReturnQuotaExceededResponse(context, rule, retryAfter);\n\n                            return;\n                        }\n                    }\n                }\n                // if limit is zero or less, block the request.\n                else\n                {\n                    // log blocked request\n                    LogBlockedRequest(context, identity, rateLimitCounter, rule);\n\n                    if (_options.RequestBlockedBehaviorAsync != null)\n                    {\n                        await _options.RequestBlockedBehaviorAsync(context, identity, rateLimitCounter, rule);\n                    }\n\n                    if (!rule.MonitorMode)\n                    {\n                        // break execution (Int32 max used to represent infinity)\n                        await ReturnQuotaExceededResponse(context, rule, int.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture));\n\n                        return;\n                    }\n                }\n\n                rulesDict.Add(rule, rateLimitCounter);\n            }\n\n            // set X-Rate-Limit headers for the longest period\n            if (rulesDict.Any() && !_options.DisableRateLimitHeaders)\n            {\n                var rule = rulesDict.OrderByDescending(x => x.Key.PeriodTimespan).FirstOrDefault();\n                var headers = _processor.GetRateLimitHeaders(rule.Value, rule.Key, context.RequestAborted);\n\n                headers.Context = context;\n\n                context.Response.OnStarting(SetRateLimitHeaders, state: headers);\n            }\n\n            await _next.Invoke(context);\n        }",
    "line_range": [
        29,
        125
    ],
    "command_specific_fields": {
        "method_name": "Invoke"
    },
    "language": "csharp",
    "commit": "3a574a8e6a6ab1bfe3ecf285490568c08cf1aa65",
    "prompt": ""
}