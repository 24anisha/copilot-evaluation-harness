{
    "case_id": "case-1265",
    "repo_name": "cool-RR/PySnooper",
    "file_path": "pysnooper/tracer.py",
    "code_snippet": "        ### Finished writing elapsed time. ####################################\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename == Tracer.__enter__.__code__.co_filename\n\n    def set_thread_info_padding(self, thread_info):\n        current_thread_len = len(thread_info)\n        self.thread_info_padding = max(self.thread_info_padding,\n                                       current_thread_len)\n        return thread_info.ljust(self.thread_info_padding)\n\n    def trace(self, frame, event, arg):\n\n        ### Checking whether we should trace this line: #######################\n        #                                                                     #\n        # We should trace this line either if it's in the decorated function,\n        # or the user asked to go a few levels deeper and we're within that\n        # number of levels deeper.\n\n        if not (frame.f_code in self.target_codes or frame in self.target_frames):\n            if self.depth == 1:\n                # We did the most common and quickest check above, because the\n                # trace function runs so incredibly often, therefore it's\n                # crucial to hyper-optimize it for the common case.\n                return None\n            elif self._is_internal_frame(frame):\n                return None\n            else:\n                _frame_candidate = frame\n                for i in range(1, self.depth):\n                    _frame_candidate = _frame_candidate.f_back\n                    if _frame_candidate is None:\n                        return None\n                    elif _frame_candidate.f_code in self.target_codes or _frame_candidate in self.target_frames:\n                        break\n                else:\n                    return None\n\n        #                                                                     #\n        ### Finished checking whether we should trace this line. ##############\n\n        if event == 'call':\n            thread_global.depth += 1\n        indent = ' ' * 4 * thread_global.depth\n\n        _FOREGROUND_BLUE = self._FOREGROUND_BLUE\n        _FOREGROUND_CYAN = self._FOREGROUND_CYAN\n        _FOREGROUND_GREEN = self._FOREGROUND_GREEN\n        _FOREGROUND_MAGENTA = self._FOREGROUND_MAGENTA\n        _FOREGROUND_RED = self._FOREGROUND_RED\n        _FOREGROUND_RESET = self._FOREGROUND_RESET\n        _FOREGROUND_YELLOW = self._FOREGROUND_YELLOW\n        _STYLE_BRIGHT = self._STYLE_BRIGHT\n        _STYLE_DIM = self._STYLE_DIM\n        _STYLE_NORMAL = self._STYLE_NORMAL\n        _STYLE_RESET_ALL = self._STYLE_RESET_ALL\n\n        ### Making timestamp: #################################################\n        #                                                                     #\n        if self.normalize:\n            timestamp = ' ' * 15\n        elif self.relative_time:\n            try:\n                start_time = self.start_times[frame]\n            except KeyError:\n                start_time = self.start_times[frame] = \\\n                                                 datetime_module.datetime.now()\n            duration = datetime_module.datetime.now() - start_time\n            timestamp = pycompat.timedelta_format(duration)\n        else:\n            timestamp = pycompat.time_isoformat(\n                datetime_module.datetime.now().time(),\n                timespec='microseconds'\n            )\n        #                                                                     #\n        ### Finished making timestamp. ########################################\n\n        line_no = frame.f_lineno\n        source_path, source = get_path_and_source_from_frame(frame)\n        source_path = source_path if not self.normalize else os.path.basename(source_path)\n        if self.last_source_path != source_path:\n            self.write(u'{_FOREGROUND_YELLOW}{_STYLE_DIM}{indent}Source path:... '\n                       u'{_STYLE_NORMAL}{source_path}'\n                       u'{_STYLE_RESET_ALL}'.format(**locals()))\n            self.last_source_path = source_path\n        source_line = source[line_no - 1]\n        thread_info = \"\"\n        if self.thread_info:\n            if self.normalize:\n                raise NotImplementedError(\"normalize is not supported with \"\n                                          \"thread_info\")\n            current_thread = threading.current_thread()\n            thread_info = \"{ident}-{name} \".format(\n                ident=current_thread.ident, name=current_thread.name)\n        thread_info = self.set_thread_info_padding(thread_info)\n\n        ### Reporting newish and modified variables: ##########################\n        #                                                                     #\n        old_local_reprs = self.frame_to_local_reprs.get(frame, {})\n        self.frame_to_local_reprs[frame] = local_reprs = \\\n                                       get_local_reprs(frame,\n                                                       watch=self.watch, custom_repr=self.custom_repr,\n                                                       max_length=self.max_variable_length,\n                                                       normalize=self.normalize,\n                                                       )\n\n        newish_string = ('Starting var:.. ' if event == 'call' else\n                                                            'New var:....... ')\n\n        for name, value_repr in local_reprs.items():\n            if name not in old_local_reprs:\n                self.write('{indent}{_FOREGROUND_GREEN}{_STYLE_DIM}'\n                           '{newish_string}{_STYLE_NORMAL}{name} = '\n                           '{value_repr}{_STYLE_RESET_ALL}'.format(**locals()))\n            elif old_local_reprs[name] != value_repr:\n                self.write('{indent}{_FOREGROUND_GREEN}{_STYLE_DIM}'\n                           'Modified var:.. {_STYLE_NORMAL}{name} = '\n                           '{value_repr}{_STYLE_RESET_ALL}'.format(**locals()))\n\n        #                                                                     #\n        ### Finished newish and modified variables. ###########################\n\n\n        ### Dealing with misplaced function definition: #######################\n        #                                                                     #\n        if event == 'call' and source_line.lstrip().startswith('@'):\n            # If a function decorator is found, skip lines until an actual\n            # function definition is found.\n            for candidate_line_no in itertools.count(line_no):\n                try:\n                    candidate_source_line = source[candidate_line_no - 1]\n                except IndexError:\n                    # End of source file reached without finding a function\n                    # definition. Fall back to original source line.\n                    break\n\n                if candidate_source_line.lstrip().startswith('def'):\n                    # Found the def line!\n                    line_no = candidate_line_no\n                    source_line = candidate_source_line\n                    break\n        #                                                                     #\n        ### Finished dealing with misplaced function definition. ##############\n\n        # If a call ends due to an exception, we still get a 'return' event\n        # with arg = None. This seems to be the only way to tell the difference\n        # https://stackoverflow.com/a/12800909/2482744\n        code_byte = frame.f_code.co_code[frame.f_lasti]\n        if not isinstance(code_byte, int):\n            code_byte = ord(code_byte)\n        ended_by_exception = (\n                event == 'return'\n                and arg is None\n                and opcode.opname[code_byte] not in RETURN_OPCODES\n        )\n\n        if ended_by_exception:\n            self.write('{_FOREGROUND_RED}{indent}Call ended by exception{_STYLE_RESET_ALL}'.\n                       format(**locals()))\n        else:\n            self.write(u'{indent}{_STYLE_DIM}{timestamp} {thread_info}{event:9} '\n                       u'{line_no:4}{_STYLE_RESET_ALL} {source_line}'.format(**locals()))\n\n        if event == 'return':\n            self.frame_to_local_reprs.pop(frame, None)\n            self.start_times.pop(frame, None)\n            thread_global.depth -= 1\n\n            if not ended_by_exception:\n                return_value_repr = utils.get_shortish_repr(arg,\n                                                            custom_repr=self.custom_repr,\n                                                            max_length=self.max_variable_length,\n                                                            normalize=self.normalize,\n                                                            )\n                self.write('{indent}{_FOREGROUND_CYAN}{_STYLE_DIM}'\n                           'Return value:.. {_STYLE_NORMAL}{return_value_repr}'\n                           '{_STYLE_RESET_ALL}'.\n                           format(**locals()))\n\n",
    "line_range": [
        391,
        569
    ],
    "command_specific_fields": {
        "method_name": "trace"
    },
    "language": "python",
    "commit": "f2c60de87f318a9c6b6c8b6887fe31bd07f91fb9",
    "prompt": ""
}