{
    "case_id": "case-0",
    "repo_name": "cool-RR/PySnooper",
    "file_path": "pysnooper/tracer.py",
    "code_snippet": "        if not (frame.f_code in self.target_codes or frame in self.target_frames):\n            if self.depth == 1:\n                \n                \n                \n                return None\n            elif self._is_internal_frame(frame):\n                return None\n            else:\n                _frame_candidate = frame\n                for i in range(1, self.depth):\n                    _frame_candidate = _frame_candidate.f_back\n                    if _frame_candidate is None:\n                        return None\n                    elif _frame_candidate.f_code in self.target_codes or _frame_candidate in self.target_frames:\n                        break\n                else:\n                    return None\n\n        \n        \n\n        if event == 'call':\n            thread_global.depth += 1\n        indent = ' ' * 4 * thread_global.depth\n\n        _FOREGROUND_BLUE = self._FOREGROUND_BLUE\n        _FOREGROUND_CYAN = self._FOREGROUND_CYAN\n        _FOREGROUND_GREEN = self._FOREGROUND_GREEN\n        _FOREGROUND_MAGENTA = self._FOREGROUND_MAGENTA\n        _FOREGROUND_RED = self._FOREGROUND_RED\n        _FOREGROUND_RESET = self._FOREGROUND_RESET\n        _FOREGROUND_YELLOW = self._FOREGROUND_YELLOW\n        _STYLE_BRIGHT = self._STYLE_BRIGHT\n        _STYLE_DIM = self._STYLE_DIM\n        _STYLE_NORMAL = self._STYLE_NORMAL\n        _STYLE_RESET_ALL = self._STYLE_RESET_ALL\n\n        \n        \n        if self.normalize:\n            timestamp = ' ' * 15\n        elif self.relative_time:\n            try:\n                start_time = self.start_times[frame]\n            except KeyError:\n                start_time = self.start_times[frame] = \\\n                                                 datetime_module.datetime.now()\n            duration = datetime_module.datetime.now() - start_time\n            timestamp = pycompat.timedelta_format(duration)\n        else:\n            timestamp = pycompat.time_isoformat(\n                datetime_module.datetime.now().time(),\n                timespec='microseconds'\n            )\n        \n        \n\n        line_no = frame.f_lineno\n        source_path, source = get_path_and_source_from_frame(frame)\n        source_path = source_path if not self.normalize else os.path.basename(source_path)\n        if self.last_source_path != source_path:\n            self.write(u'{_FOREGROUND_YELLOW}{_STYLE_DIM}{indent}Source path:... '\n                       u'{_STYLE_NORMAL}{source_path}'\n                       u'{_STYLE_RESET_ALL}'.format(**locals()))\n            self.last_source_path = source_path\n        source_line = source[line_no - 1]\n        thread_info = \"\"\n        if self.thread_info:\n            if self.normalize:\n                raise NotImplementedError(\"normalize is not supported with \"\n                                          \"thread_info\")\n            current_thread = threading.current_thread()\n            thread_info = \"{ident}-{name} \".format(\n                ident=current_thread.ident, name=current_thread.name)\n        thread_info = self.set_thread_info_padding(thread_info)\n\n        \n        \n        old_local_reprs = self.frame_to_local_reprs.get(frame, {})\n        self.frame_to_local_reprs[frame] = local_reprs = \\\n                                       get_local_reprs(frame,\n                                                       watch=self.watch, custom_repr=self.custom_repr,\n                                                       max_length=self.max_variable_length,\n                                                       normalize=self.normalize,\n                                                       )\n\n        newish_string = ('Starting var:.. ' if event == 'call' else\n                                                            'New var:....... ')\n\n        for name, value_repr in local_reprs.items():\n            if name not in old_local_reprs:\n                self.write('{indent}{_FOREGROUND_GREEN}{_STYLE_DIM}'\n                           '{newish_string}{_STYLE_NORMAL}{name} = '\n                           '{value_repr}{_STYLE_RESET_ALL}'.format(**locals()))\n            elif old_local_reprs[name] != value_repr:\n                self.write('{indent}{_FOREGROUND_GREEN}{_STYLE_DIM}'\n                           'Modified var:.. {_STYLE_NORMAL}{name} = '\n                           '{value_repr}{_STYLE_RESET_ALL}'.format(**locals()))\n\n        \n        \n\n\n        \n        \n        if event == 'call' and source_line.lstrip().startswith('@'):\n            \n            \n            for candidate_line_no in itertools.count(line_no):\n                try:\n                    candidate_source_line = source[candidate_line_no - 1]\n                except IndexError:\n                    \n                    \n                    break\n\n                if candidate_source_line.lstrip().startswith('def'):\n                    \n                    line_no = candidate_line_no\n                    source_line = candidate_source_line\n                    break\n        \n        \n\n        \n        \n        \n        code_byte = frame.f_code.co_code[frame.f_lasti]\n        if not isinstance(code_byte, int):\n            code_byte = ord(code_byte)\n        ended_by_exception = (\n                event == 'return'\n                and arg is None\n                and opcode.opname[code_byte] not in RETURN_OPCODES\n        )\n\n        if ended_by_exception:\n            self.write('{_FOREGROUND_RED}{indent}Call ended by exception{_STYLE_RESET_ALL}'.\n                       format(**locals()))\n        else:\n            self.write(u'{indent}{_STYLE_DIM}{timestamp} {thread_info}{event:9} '\n                       u'{line_no:4}{_STYLE_RESET_ALL} {source_line}'.format(**locals()))\n\n        if event == 'return':\n            self.frame_to_local_reprs.pop(frame, None)\n            self.start_times.pop(frame, None)\n            thread_global.depth -= 1\n\n            if not ended_by_exception:\n                return_value_repr = utils.get_shortish_repr(arg,\n                                                            custom_repr=self.custom_repr,\n                                                            max_length=self.max_variable_length,\n                                                            normalize=self.normalize,\n                                                            )\n                self.write('{indent}{_FOREGROUND_CYAN}{_STYLE_DIM}'\n                           'Return value:.. {_STYLE_NORMAL}{return_value_repr}'\n                           '{_STYLE_RESET_ALL}'.\n                           format(**locals()))\n\n        if event == 'exception':\n            exception = '\\n'.join(traceback.format_exception_only(*arg[:2])).strip()\n            if self.max_variable_length:\n                exception = utils.truncate(exception, self.max_variable_length)\n            self.write('{indent}{_FOREGROUND_RED}Exception:..... '\n                       '{_STYLE_BRIGHT}{exception}'\n                       '{_STYLE_RESET_ALL}'.format(**locals()))\n\n        return self.trace",
    "line_range": [
        391,
        569
    ],
    "command_specific_fields": {
        "method_name": "trace"
    },
    "language": "python",
    "commit": "f2c60de87f318a9c6b6c8b6887fe31bd07f91fb9"
}