{
    "case_id": "case-515",
    "repo_name": "kelektiv/node-cron",
    "file_path": "src/time.ts",
    "code_snippet": "\t */\n\n\n\n\tprivate _parseField(value: string, unit: TimeUnit) {\n\n\t\tconst typeObj = this[unit] as TimeUnitField<typeof unit>;\n\n\t\tlet pointer: Ranges[typeof unit];\n\n\n\n\t\tconst constraints = CONSTRAINTS[unit];\n\n\t\tconst low = constraints[0];\n\n\t\tconst high = constraints[1];\n\n\n\n\t\tconst fields = value.split(',');\n\n\t\tfields.forEach(field => {\n\n\t\t\tconst wildcardIndex = field.indexOf('*');\n\n\t\t\tif (wildcardIndex !== -1 && wildcardIndex !== 0) {\n\n\t\t\t\tthrow new CronError(\n\n\t\t\t\t\t`Field (${field}) has an invalid wildcard expression`\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t});\n\n\n\n\t\t// \"*\" is a shortcut to [low-high] range for the field\n\n\t\tvalue = value.replace(RE_WILDCARDS, `${low}-${high}`);\n\n\n\n\t\t// commas separate information, so split based on those\n\n\t\tconst allRanges = value.split(',');\n\n\n\n\t\tfor (const range of allRanges) {\n\n\t\t\tconst match = [...range.matchAll(RE_RANGE)][0];\n\n\t\t\tif (match?.[1] !== undefined) {\n\n\t\t\t\tconst [, mLower, mUpper, mStep] = match;\n\n\t\t\t\tlet lower = parseInt(mLower, 10);\n\n\t\t\t\tlet upper = mUpper !== undefined ? parseInt(mUpper, 10) : undefined;\n\n\n\n\t\t\t\tconst wasStepDefined = mStep !== undefined;\n\n\t\t\t\tconst step = parseInt(mStep ?? '1', 10);\n\n\t\t\t\tif (step === 0) {\n\n\t\t\t\t\tthrow new CronError(`Field (${unit}) has a step of zero`);\n\n\t\t\t\t}\n\n\n\n\t\t\t\tif (upper !== undefined && lower > upper) {\n\n\t\t\t\t\tthrow new CronError(`Field (${unit}) has an invalid range`);\n\n\t\t\t\t}\n\n\n\n\t\t\t\tconst isOutOfRange =\n\n\t\t\t\t\tlower < low ||\n\n\t\t\t\t\t(upper !== undefined && upper > high) ||\n\n\t\t\t\t\t(upper === undefined && lower > high);\n\n\n\n\t\t\t\tif (isOutOfRange) {\n\n\t\t\t\t\tthrow new CronError(`Field value (${value}) is out of range`);\n\n\t\t\t\t}\n\n\n\n\t\t\t\t// Positive integer higher than constraints[0]\n\n\t\t\t\tlower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n\n\n\n\t\t\t\t// Positive integer lower than constraints[1]\n\n\t\t\t\tif (upper !== undefined) {\n\n\t\t\t\t\tupper = Math.min(high, ~~Math.abs(upper));\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If step is provided, the default upper range is the highest value\n\n\t\t\t\t\tupper = wasStepDefined ? high : lower;\n\n\t\t\t\t}\n\n\n\n\t\t\t\t// Count from the lower barrier to the upper\n\n\t\t\t\t// forcing type cast here since we checked above that\n\n\t\t\t\t// we are between constraint bounds\n\n\t\t\t\tpointer = lower as typeof pointer;\n\n\n\n\t\t\t\tdo {\n\n\t\t\t\t\ttypeObj[pointer] = true; // mutates the field objects values inside CronTime\n\n\t\t\t\t\tpointer += step;\n\n\t\t\t\t} while (pointer <= upper);\n\n\n\n\t\t\t\t// merge day 7 into day 0 (both Sunday), and remove day 7\n\n\t\t\t\t// since we work with day-of-week 0-6 under the hood\n\n\t\t\t\tif (unit === 'dayOfWeek') {\n\n\t\t\t\t\tif (!typeObj[0] && !!typeObj[7]) typeObj[0] = typeObj[7];\n\n\t\t\t\t\tdelete typeObj[7];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow new CronError(`Field (${unit}) cannot be parsed`);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n",
    "line_range": [
        745,
        828
    ],
    "command_specific_fields": {
        "method_name": "_parseField"
    },
    "language": "typescript",
    "commit": "1eb978b8cddf8a2f2bead841adcad408238333c6",
    "prompt": ""
}