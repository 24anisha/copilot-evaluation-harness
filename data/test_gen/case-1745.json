{
    "case_id": "case-1745",
    "repo_name": "google/yapf",
    "file_path": "yapf/yapflib/reformatter.py",
    "code_snippet": "\n\ndef _CalculateNumberOfNewlines(first_token, indent_depth, prev_line,\n                               final_lines, first_nested):\n  \"\"\"Calculate the number of newlines we need to add.\n\n  Arguments:\n    first_token: (format_token.FormatToken) The first token in the logical\n      line.\n    indent_depth: (int) The line's indentation depth.\n    prev_line: (list of logical_line.LogicalLine) The logical line previous to\n      this line.\n    final_lines: (list of logical_line.LogicalLine) The logical lines that have\n      already been processed.\n    first_nested: (boolean) Whether this is the first nested class or function.\n\n  Returns:\n    The number of newlines needed before the first token.\n  \"\"\"\n  # TODO(morbo): Special handling for imports.\n  # TODO(morbo): Create a knob that can tune these.\n  if prev_line is None:\n    # The first line in the file. Don't add blank lines.\n    # FIXME(morbo): Is this correct?\n    if first_token.newlines is not None:\n      first_token.newlines = None\n    return 0\n\n  if first_token.is_docstring:\n    if (prev_line.first.value == 'class' and\n        style.Get('BLANK_LINE_BEFORE_CLASS_DOCSTRING')):\n      # Enforce a blank line before a class's docstring.\n      return ONE_BLANK_LINE\n    elif (prev_line.first.value.startswith('#') and\n          style.Get('BLANK_LINE_BEFORE_MODULE_DOCSTRING')):\n      # Enforce a blank line before a module's docstring.\n      return ONE_BLANK_LINE\n    # The docstring shouldn't have a newline before it.\n    return NO_BLANK_LINES\n\n  if first_token.is_name and not indent_depth:\n    if prev_line.first.value in {'from', 'import'}:\n      # Support custom number of blank lines between top-level imports and\n      # variable definitions.\n      return 1 + style.Get(\n          'BLANK_LINES_BETWEEN_TOP_LEVEL_IMPORTS_AND_VARIABLES')\n\n  prev_last_token = prev_line.last\n  if prev_last_token.is_docstring:\n    if (not indent_depth and first_token.value in {'class', 'def', 'async'}):\n      # Separate a class or function from the module-level docstring with\n      # appropriate number of blank lines.\n      return 1 + style.Get('BLANK_LINES_AROUND_TOP_LEVEL_DEFINITION')\n    if (first_nested and\n        not style.Get('BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF') and\n        _IsClassOrDef(first_token)):\n      first_token.newlines = None\n      return NO_BLANK_LINES\n    if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token,\n                                       prev_last_token):\n      return NO_BLANK_LINES\n    else:\n      return ONE_BLANK_LINE\n\n  if _IsClassOrDef(first_token):\n    # TODO(morbo): This can go once the blank line calculator is more\n    # sophisticated.\n    if not indent_depth:\n      # This is a top-level class or function.\n      is_inline_comment = prev_last_token.whitespace_prefix.count('\\n') == 0\n      if (not prev_line.disable and prev_last_token.is_comment and\n          not is_inline_comment):\n        # This token follows a non-inline comment.\n        if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token,\n                                           prev_last_token):\n          # Assume that the comment is \"attached\" to the current line.\n          # Therefore, we want two blank lines before the comment.\n          index = len(final_lines) - 1\n          while index > 0:\n            if not final_lines[index - 1].is_comment:\n              break\n            index -= 1\n          if final_lines[index - 1].first.value == '@':\n            final_lines[index].first.AdjustNewlinesBefore(NO_BLANK_LINES)\n          else:\n            prev_last_token.AdjustNewlinesBefore(\n                1 + style.Get('BLANK_LINES_AROUND_TOP_LEVEL_DEFINITION'))\n          if first_token.newlines is not None:\n            first_token.newlines = None\n          return NO_BLANK_LINES\n    elif _IsClassOrDef(prev_line.first):\n      if first_nested and not style.Get(\n          'BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF'):\n        first_token.newlines = None\n        return NO_BLANK_LINES\n\n  # Calculate how many newlines were between the original lines. We want to\n  # retain that formatting if it doesn't violate one of the style guide rules.\n  if first_token.is_comment:\n    first_token_lineno = first_token.lineno - first_token.value.count('\\n')\n  else:\n    first_token_lineno = first_token.lineno\n\n  prev_last_token_lineno = prev_last_token.lineno\n  if prev_last_token.is_multiline_string:\n    prev_last_token_lineno += prev_last_token.value.count('\\n')\n\n  if first_token_lineno - prev_last_token_lineno > 1:\n    return ONE_BLANK_LINE\n\n  return NO_BLANK_LINES\n",
    "line_range": [
        605,
        715
    ],
    "command_specific_fields": {
        "method_name": "_CalculateNumberOfNewlines"
    },
    "language": "python",
    "commit": "1afbf7112ae61a467276c9401b3c113e6f676d0f",
    "prompt": ""
}