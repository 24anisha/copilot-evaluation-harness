{
    "case_id": "case-1745",
    "repo_name": "google/yapf",
    "file_path": "yapf/yapflib/reformatter.py",
    "code_snippet": "\n\n\n\ndef _CalculateNumberOfNewlines(first_token, indent_depth, prev_line,\n\n                               final_lines, first_nested):\n\n  \"\"\"Calculate the number of newlines we need to add.\n\n\n\n  Arguments:\n\n    first_token: (format_token.FormatToken) The first token in the logical\n\n      line.\n\n    indent_depth: (int) The line's indentation depth.\n\n    prev_line: (list of logical_line.LogicalLine) The logical line previous to\n\n      this line.\n\n    final_lines: (list of logical_line.LogicalLine) The logical lines that have\n\n      already been processed.\n\n    first_nested: (boolean) Whether this is the first nested class or function.\n\n\n\n  Returns:\n\n    The number of newlines needed before the first token.\n\n  \"\"\"\n\n  # TODO(morbo): Special handling for imports.\n\n  # TODO(morbo): Create a knob that can tune these.\n\n  if prev_line is None:\n\n    # The first line in the file. Don't add blank lines.\n\n    # FIXME(morbo): Is this correct?\n\n    if first_token.newlines is not None:\n\n      first_token.newlines = None\n\n    return 0\n\n\n\n  if first_token.is_docstring:\n\n    if (prev_line.first.value == 'class' and\n\n        style.Get('BLANK_LINE_BEFORE_CLASS_DOCSTRING')):\n\n      # Enforce a blank line before a class's docstring.\n\n      return ONE_BLANK_LINE\n\n    elif (prev_line.first.value.startswith('#') and\n\n          style.Get('BLANK_LINE_BEFORE_MODULE_DOCSTRING')):\n\n      # Enforce a blank line before a module's docstring.\n\n      return ONE_BLANK_LINE\n\n    # The docstring shouldn't have a newline before it.\n\n    return NO_BLANK_LINES\n\n\n\n  if first_token.is_name and not indent_depth:\n\n    if prev_line.first.value in {'from', 'import'}:\n\n      # Support custom number of blank lines between top-level imports and\n\n      # variable definitions.\n\n      return 1 + style.Get(\n\n          'BLANK_LINES_BETWEEN_TOP_LEVEL_IMPORTS_AND_VARIABLES')\n\n\n\n  prev_last_token = prev_line.last\n\n  if prev_last_token.is_docstring:\n\n    if (not indent_depth and first_token.value in {'class', 'def', 'async'}):\n\n      # Separate a class or function from the module-level docstring with\n\n      # appropriate number of blank lines.\n\n      return 1 + style.Get('BLANK_LINES_AROUND_TOP_LEVEL_DEFINITION')\n\n    if (first_nested and\n\n        not style.Get('BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF') and\n\n        _IsClassOrDef(first_token)):\n\n      first_token.newlines = None\n\n      return NO_BLANK_LINES\n\n    if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token,\n\n                                       prev_last_token):\n\n      return NO_BLANK_LINES\n\n    else:\n\n      return ONE_BLANK_LINE\n\n\n\n  if _IsClassOrDef(first_token):\n\n    # TODO(morbo): This can go once the blank line calculator is more\n\n    # sophisticated.\n\n    if not indent_depth:\n\n      # This is a top-level class or function.\n\n      is_inline_comment = prev_last_token.whitespace_prefix.count('\\n') == 0\n\n      if (not prev_line.disable and prev_last_token.is_comment and\n\n          not is_inline_comment):\n\n        # This token follows a non-inline comment.\n\n        if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token,\n\n                                           prev_last_token):\n\n          # Assume that the comment is \"attached\" to the current line.\n\n          # Therefore, we want two blank lines before the comment.\n\n          index = len(final_lines) - 1\n\n          while index > 0:\n\n            if not final_lines[index - 1].is_comment:\n\n              break\n\n            index -= 1\n\n          if final_lines[index - 1].first.value == '@':\n\n            final_lines[index].first.AdjustNewlinesBefore(NO_BLANK_LINES)\n\n          else:\n\n            prev_last_token.AdjustNewlinesBefore(\n\n                1 + style.Get('BLANK_LINES_AROUND_TOP_LEVEL_DEFINITION'))\n\n          if first_token.newlines is not None:\n\n            first_token.newlines = None\n\n          return NO_BLANK_LINES\n\n    elif _IsClassOrDef(prev_line.first):\n\n      if first_nested and not style.Get(\n\n          'BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF'):\n\n        first_token.newlines = None\n\n        return NO_BLANK_LINES\n\n\n\n  # Calculate how many newlines were between the original lines. We want to\n\n  # retain that formatting if it doesn't violate one of the style guide rules.\n\n  if first_token.is_comment:\n\n    first_token_lineno = first_token.lineno - first_token.value.count('\\n')\n\n  else:\n\n    first_token_lineno = first_token.lineno\n\n\n\n  prev_last_token_lineno = prev_last_token.lineno\n\n  if prev_last_token.is_multiline_string:\n\n    prev_last_token_lineno += prev_last_token.value.count('\\n')\n\n\n\n  if first_token_lineno - prev_last_token_lineno > 1:\n\n    return ONE_BLANK_LINE\n\n\n\n  return NO_BLANK_LINES\n",
    "line_range": [
        605,
        715
    ],
    "command_specific_fields": {
        "method_name": "_CalculateNumberOfNewlines"
    },
    "language": "python",
    "commit": "1afbf7112ae61a467276c9401b3c113e6f676d0f",
    "prompt": ""
}