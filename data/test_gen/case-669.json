{
    "case_id": "case-669",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/algorithms/distance_measures.py",
    "code_snippet": "\n\n\n\n@not_implemented_for(\"directed\")\n\n@nx._dispatchable(edge_attrs=\"weight\")\n\ndef effective_graph_resistance(G, weight=None, invert_weight=True):\n\n    \"\"\"Returns the Effective graph resistance of G.\n\n\n\n    Also known as the Kirchhoff index.\n\n\n\n    The effective graph resistance is defined as the sum\n\n    of the resistance distance of every node pair in G [1]_.\n\n\n\n    If weight is not provided, then a weight of 1 is used for all edges.\n\n\n\n    The effective graph resistance of a disconnected graph is infinite.\n\n\n\n    Parameters\n\n    ----------\n\n    G : NetworkX graph\n\n       A graph\n\n\n\n    weight : string or None, optional (default=None)\n\n       The edge data key used to compute the effective graph resistance.\n\n       If None, then each edge has weight 1.\n\n\n\n    invert_weight : boolean (default=True)\n\n        Proper calculation of resistance distance requires building the\n\n        Laplacian matrix with the reciprocal of the weight. Not required\n\n        if the weight is already inverted. Weight cannot be zero.\n\n\n\n    Returns\n\n    -------\n\n    RG : float\n\n        The effective graph resistance of `G`.\n\n\n\n    Raises\n\n    ------\n\n    NetworkXNotImplemented\n\n        If `G` is a directed graph.\n\n\n\n    NetworkXError\n\n        If `G` does not contain any nodes.\n\n\n\n    Examples\n\n    --------\n\n    >>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n\n    >>> round(nx.effective_graph_resistance(G), 10)\n\n    10.25\n\n\n\n    Notes\n\n    -----\n\n    The implementation is based on Theorem 2.2 in [2]_. Self-loops are ignored.\n\n    Multi-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\n\n\n\n    References\n\n    ----------\n\n    .. [1] Wolfram\n\n       \"Kirchhoff Index.\"\n\n       https://mathworld.wolfram.com/KirchhoffIndex.html\n\n    .. [2] W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\n\n        Effective graph resistance.\n\n        Lin. Alg. Appl. 435:2491-2506, 2011.\n\n    \"\"\"\n\n    import numpy as np\n\n\n\n    if len(G) == 0:\n\n        raise nx.NetworkXError(\"Graph G must contain at least one node.\")\n\n\n\n    # Disconnected graphs have infinite Effective graph resistance\n\n    if not nx.is_connected(G):\n\n        return float(\"inf\")\n\n\n\n    # Invert weights\n\n    G = G.copy()\n\n    if invert_weight and weight is not None:\n\n        if G.is_multigraph():\n\n            for u, v, k, d in G.edges(keys=True, data=True):\n\n                d[weight] = 1 / d[weight]\n\n        else:\n\n            for u, v, d in G.edges(data=True):\n\n                d[weight] = 1 / d[weight]\n\n\n\n    # Get Laplacian eigenvalues\n\n    mu = np.sort(nx.laplacian_spectrum(G, weight=weight))\n\n\n\n    # Compute Effective graph resistance based on spectrum of the Laplacian\n\n    # Self-loops are ignored\n\n    return float(np.sum(1 / mu[1:]) * G.number_of_nodes())\n",
    "line_range": [
        774,
        861
    ],
    "command_specific_fields": {
        "method_name": "effective_graph_resistance"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}