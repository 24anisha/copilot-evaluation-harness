{
    "case_id": "case-669",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/algorithms/distance_measures.py",
    "code_snippet": "    Notes\n    -----\n    The implementation is based on Theorem A in [2]_. Self-loops are ignored.\n    Multi-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\n\n    References\n    ----------\n    .. [1] Wikipedia\n       \"Resistance distance.\"\n       https://en.wikipedia.org/wiki/Resistance_distance\n    .. [2] D. J. Klein and M. Randic.\n        Resistance distance.\n        J. of Math. Chem. 12:81-95, 1993.\n    \"\"\"\n    import numpy as np\n\n    if len(G) == 0:\n        raise nx.NetworkXError(\"Graph G must contain at least one node.\")\n    if not nx.is_connected(G):\n        raise nx.NetworkXError(\"Graph G must be strongly connected.\")\n    if nodeA is not None and nodeA not in G:\n        raise nx.NetworkXError(\"Node A is not in graph G.\")\n    if nodeB is not None and nodeB not in G:\n        raise nx.NetworkXError(\"Node B is not in graph G.\")\n\n    G = G.copy()\n    node_list = list(G)\n\n    # Invert weights\n    if invert_weight and weight is not None:\n        if G.is_multigraph():\n            for u, v, k, d in G.edges(keys=True, data=True):\n                d[weight] = 1 / d[weight]\n        else:\n            for u, v, d in G.edges(data=True):\n                d[weight] = 1 / d[weight]\n\n    # Compute resistance distance using the Pseudo-inverse of the Laplacian\n    # Self-loops are ignored\n    L = nx.laplacian_matrix(G, weight=weight).todense()\n    Linv = np.linalg.pinv(L, hermitian=True)\n\n    # Return relevant distances\n    if nodeA is not None and nodeB is not None:\n        i = node_list.index(nodeA)\n        j = node_list.index(nodeB)\n        return Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)\n\n    elif nodeA is not None:\n        i = node_list.index(nodeA)\n        d = {}\n        for n in G:\n            j = node_list.index(n)\n            d[n] = Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)\n        return d\n\n    elif nodeB is not None:\n        j = node_list.index(nodeB)\n        d = {}\n        for n in G:\n            i = node_list.index(n)\n            d[n] = Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)\n        return d\n\n    else:\n        d = {}\n        for n in G:\n            i = node_list.index(n)\n            d[n] = {}\n            for n2 in G:\n                j = node_list.index(n2)\n                d[n][n2] = (\n                    Linv.item(i, i)\n                    + Linv.item(j, j)\n                    - Linv.item(i, j)\n                    - Linv.item(j, i)\n                )\n        return d\n\n\n@not_implemented_for(\"directed\")\n@nx._dispatchable(edge_attrs=\"weight\")\ndef effective_graph_resistance(G, weight=None, invert_weight=True):\n    \"\"\"Returns the Effective graph resistance of G.\n\n    Also known as the Kirchhoff index.\n\n    The effective graph resistance is defined as the sum\n",
    "line_range": [
        774,
        861
    ],
    "command_specific_fields": {
        "method_name": "effective_graph_resistance"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}