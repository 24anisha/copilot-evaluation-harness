{
    "case_id": "case-1617",
    "repo_name": "cool-RR/PySnooper",
    "file_path": "pysnooper/tracer.py",
    "code_snippet": "\n\n\n\ndef get_path_and_source_from_frame(frame):\n\n    globs = frame.f_globals or {}\n\n    module_name = globs.get('__name__')\n\n    file_name = frame.f_code.co_filename\n\n    cache_key = (module_name, file_name)\n\n    try:\n\n        return source_and_path_cache[cache_key]\n\n    except KeyError:\n\n        pass\n\n    loader = globs.get('__loader__')\n\n\n\n    source = None\n\n    if hasattr(loader, 'get_source'):\n\n        try:\n\n            source = loader.get_source(module_name)\n\n        except ImportError:\n\n            pass\n\n        if source is not None:\n\n            source = source.splitlines()\n\n    if source is None:\n\n        ipython_filename_match = ipython_filename_pattern.match(file_name)\n\n        ansible_filename_match = ansible_filename_pattern.match(file_name)\n\n        if ipython_filename_match:\n\n            entry_number = int(ipython_filename_match.group(1))\n\n            try:\n\n                import IPython\n\n                ipython_shell = IPython.get_ipython()\n\n                ((_, _, source_chunk),) = ipython_shell.history_manager. \\\n\n                                  get_range(0, entry_number, entry_number + 1)\n\n                source = source_chunk.splitlines()\n\n            except Exception:\n\n                pass\n\n        elif ansible_filename_match:\n\n            try:\n\n                import zipfile\n\n                archive_file = zipfile.ZipFile(ansible_filename_match.group(1), 'r')\n\n                source = archive_file.read(ansible_filename_match.group(2).replace('\\\\', '/')).splitlines()\n\n            except Exception:\n\n                pass\n\n        else:\n\n            try:\n\n                with open(file_name, 'rb') as fp:\n\n                    source = fp.read().splitlines()\n\n            except utils.file_reading_errors:\n\n                pass\n\n    if not source:\n\n        # We used to check `if source is None` but I found a rare bug where it\n\n        # was empty, but not `None`, so now we check `if not source`.\n\n        source = UnavailableSource()\n\n\n\n    # If we just read the source from a file, or if the loader did not\n\n    # apply tokenize.detect_encoding to decode the source into a\n\n    # string, then we should do that ourselves.\n\n    if isinstance(source[0], bytes):\n\n        encoding = 'utf-8'\n\n        for line in source[:2]:\n\n            # File coding may be specified. Match pattern from PEP-263\n\n            # (https://www.python.org/dev/peps/pep-0263/)\n\n            match = re.search(br'coding[:=]\\s*([-\\w.]+)', line)\n\n            if match:\n\n                encoding = match.group(1).decode('ascii')\n\n                break\n\n        source = [pycompat.text_type(sline, encoding, 'replace') for sline in\n\n                  source]\n\n\n\n    result = (file_name, source)\n\n    source_and_path_cache[cache_key] = result\n\n    return result\n",
    "line_range": [
        53,
        122
    ],
    "command_specific_fields": {
        "method_name": "get_path_and_source_from_frame"
    },
    "language": "python",
    "commit": "f2c60de87f318a9c6b6c8b6887fe31bd07f91fb9",
    "prompt": ""
}