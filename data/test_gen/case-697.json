{
    "case_id": "case-697",
    "repo_name": "dbader/schedule",
    "file_path": "schedule/__init__.py",
    "code_snippet": "        return self\n\n\n\n    def at(self, time_str: str, tz: Optional[str] = None):\n\n        \"\"\"\n\n        Specify a particular time that the job should be run at.\n\n\n\n        :param time_str: A string in one of the following formats:\n\n\n\n            - For daily jobs -> `HH:MM:SS` or `HH:MM`\n\n            - For hourly jobs -> `MM:SS` or `:MM`\n\n            - For minute jobs -> `:SS`\n\n\n\n            The format must make sense given how often the job is\n\n            repeating; for example, a job that repeats every minute\n\n            should not be given a string in the form `HH:MM:SS`. The\n\n            difference between `:MM` and `:SS` is inferred from the\n\n            selected time-unit (e.g. `every().hour.at(':30')` vs.\n\n            `every().minute.at(':30')`).\n\n\n\n        :param tz: The timezone that this timestamp refers to. Can be\n\n            a string that can be parsed by pytz.timezone(), or a pytz.BaseTzInfo object\n\n\n\n        :return: The invoked job instance\n\n        \"\"\"\n\n        if self.unit not in (\"days\", \"hours\", \"minutes\") and not self.start_day:\n\n            raise ScheduleValueError(\n\n                \"Invalid unit (valid units are `days`, `hours`, and `minutes`)\"\n\n            )\n\n\n\n        if tz is not None:\n\n            import pytz\n\n\n\n            if isinstance(tz, str):\n\n                self.at_time_zone = pytz.timezone(tz)  # type: ignore\n\n            elif isinstance(tz, pytz.BaseTzInfo):\n\n                self.at_time_zone = tz\n\n            else:\n\n                raise ScheduleValueError(\n\n                    \"Timezone must be string or pytz.timezone object\"\n\n                )\n\n\n\n        if not isinstance(time_str, str):\n\n            raise TypeError(\"at() should be passed a string\")\n\n        if self.unit == \"days\" or self.start_day:\n\n            if not re.match(r\"^[0-2]\\d:[0-5]\\d(:[0-5]\\d)?$\", time_str):\n\n                raise ScheduleValueError(\n\n                    \"Invalid time format for a daily job (valid format is HH:MM(:SS)?)\"\n\n                )\n\n        if self.unit == \"hours\":\n\n            if not re.match(r\"^([0-5]\\d)?:[0-5]\\d$\", time_str):\n\n                raise ScheduleValueError(\n\n                    \"Invalid time format for an hourly job (valid format is (MM)?:SS)\"\n\n                )\n\n\n\n        if self.unit == \"minutes\":\n\n            if not re.match(r\"^:[0-5]\\d$\", time_str):\n\n                raise ScheduleValueError(\n\n                    \"Invalid time format for a minutely job (valid format is :SS)\"\n\n                )\n\n        time_values = time_str.split(\":\")\n\n        hour: Union[str, int]\n\n        minute: Union[str, int]\n\n        second: Union[str, int]\n\n        if len(time_values) == 3:\n\n            hour, minute, second = time_values\n\n        elif len(time_values) == 2 and self.unit == \"minutes\":\n\n            hour = 0\n\n            minute = 0\n\n            _, second = time_values\n\n        elif len(time_values) == 2 and self.unit == \"hours\" and len(time_values[0]):\n\n            hour = 0\n\n            minute, second = time_values\n\n        else:\n\n            hour, minute = time_values\n\n            second = 0\n\n        if self.unit == \"days\" or self.start_day:\n\n            hour = int(hour)\n\n            if not (0 <= hour <= 23):\n\n                raise ScheduleValueError(\n\n                    \"Invalid number of hours ({} is not between 0 and 23)\"\n\n                )\n\n        elif self.unit == \"hours\":\n\n            hour = 0\n\n        elif self.unit == \"minutes\":\n\n            hour = 0\n\n            minute = 0\n\n        hour = int(hour)\n\n        minute = int(minute)\n\n        second = int(second)\n\n        self.at_time = datetime.time(hour, minute, second)\n\n        return self\n",
    "line_range": [
        469,
        559
    ],
    "command_specific_fields": {
        "method_name": "at"
    },
    "language": "python",
    "commit": "82a43db1b938d8fdf60103bd41f329e06c8d3651",
    "prompt": ""
}