{
    "case_id": "case-792",
    "repo_name": "Zulko/moviepy",
    "file_path": "moviepy/video/VideoClip.py",
    "code_snippet": "        \"\"\"\n        im = self.get_frame(t)\n        if with_mask and self.mask is not None:\n            mask = 255 * self.mask.get_frame(t)\n            im = np.dstack([im, mask]).astype(\"uint8\")\n        else:\n            im = im.astype(\"uint8\")\n\n        imwrite(filename, im)\n\n    @requires_duration\n    @use_clip_fps_by_default\n    @convert_masks_to_RGB\n    @convert_path_to_string([\"filename\", \"temp_audiofile\", \"temp_audiofile_path\"])\n    def write_videofile(\n        self,\n        filename,\n        fps=None,\n        codec=None,\n        bitrate=None,\n        audio=True,\n        audio_fps=44100,\n        preset=\"medium\",\n        audio_nbytes=4,\n        audio_codec=None,\n        audio_bitrate=None,\n        audio_bufsize=2000,\n        temp_audiofile=None,\n        temp_audiofile_path=\"\",\n        remove_temp=True,\n        write_logfile=False,\n        threads=None,\n        ffmpeg_params=None,\n        logger=\"bar\",\n        pixel_format=None,\n    ):\n        \"\"\"Write the clip to a videofile.\n\n        Parameters\n        ----------\n\n        filename\n          Name of the video file to write in, as a string or a path-like object.\n          The extension must correspond to the \"codec\" used (see below),\n          or simply be '.avi' (which will work with any codec).\n\n        fps\n          Number of frames per second in the resulting video file. If None is\n          provided, and the clip has an fps attribute, this fps will be used.\n\n        codec\n          Codec to use for image encoding. Can be any codec supported\n          by ffmpeg. If the filename is has extension '.mp4', '.ogv', '.webm',\n          the codec will be set accordingly, but you can still set it if you\n          don't like the default. For other extensions, the output filename\n          must be set accordingly.\n\n          Some examples of codecs are:\n\n          - ``'libx264'`` (default codec for file extension ``.mp4``)\n            makes well-compressed videos (quality tunable using 'bitrate').\n          - ``'mpeg4'`` (other codec for extension ``.mp4``) can be an alternative\n            to ``'libx264'``, and produces higher quality videos by default.\n          - ``'rawvideo'`` (use file extension ``.avi``) will produce\n            a video of perfect quality, of possibly very huge size.\n          - ``png`` (use file extension ``.avi``) will produce a video\n            of perfect quality, of smaller size than with ``rawvideo``.\n          - ``'libvorbis'`` (use file extension ``.ogv``) is a nice video\n            format, which is completely free/ open source. However not\n            everyone has the codecs installed by default on their machine.\n          - ``'libvpx'`` (use file extension ``.webm``) is tiny a video\n            format well indicated for web videos (with HTML5). Open source.\n\n        audio\n          Either ``True``, ``False``, or a file name.\n          If ``True`` and the clip has an audio clip attached, this\n          audio clip will be incorporated as a soundtrack in the movie.\n          If ``audio`` is the name of an audio file, this audio file\n          will be incorporated as a soundtrack in the movie.\n\n        audio_fps\n          frame rate to use when generating the sound.\n\n        temp_audiofile\n          the name of the temporary audiofile, as a string or path-like object,\n          to be created and then used to write the complete video, if any.\n\n        temp_audiofile_path\n          the location that the temporary audiofile is placed, as a\n          string or path-like object. Defaults to the current working directory.\n\n        audio_codec\n          Which audio codec should be used. Examples are 'libmp3lame'\n          for '.mp3', 'libvorbis' for 'ogg', 'libfdk_aac':'m4a',\n          'pcm_s16le' for 16-bit wav and 'pcm_s32le' for 32-bit wav.\n          Default is 'libmp3lame', unless the video extension is 'ogv'\n          or 'webm', at which case the default is 'libvorbis'.\n\n        audio_bitrate\n          Audio bitrate, given as a string like '50k', '500k', '3000k'.\n          Will determine the size/quality of audio in the output file.\n          Note that it mainly an indicative goal, the bitrate won't\n          necessarily be the this in the final file.\n\n        preset\n          Sets the time that FFMPEG will spend optimizing the compression.\n          Choices are: ultrafast, superfast, veryfast, faster, fast, medium,\n          slow, slower, veryslow, placebo. Note that this does not impact\n          the quality of the video, only the size of the video file. So\n          choose ultrafast when you are in a hurry and file size does not\n          matter.\n\n        threads\n          Number of threads to use for ffmpeg. Can speed up the writing of\n          the video on multicore computers.\n\n        ffmpeg_params\n          Any additional ffmpeg parameters you would like to pass, as a list\n          of terms, like ['-option1', 'value1', '-option2', 'value2'].\n\n        write_logfile\n          If true, will write log files for the audio and the video.\n          These will be files ending with '.log' with the name of the\n          output file in them.\n\n        logger\n          Either ``\"bar\"`` for progress bar or ``None`` or any Proglog logger.\n\n        pixel_format\n          Pixel format for the output video file.\n\n        Examples\n        --------\n\n        .. code:: python\n\n            from moviepy import VideoFileClip\n            clip = VideoFileClip(\"myvideo.mp4\").subclipped(100,120)\n            clip.write_videofile(\"my_new_video.mp4\")\n            clip.close()\n\n        \"\"\"\n        name, ext = os.path.splitext(os.path.basename(filename))\n        ext = ext[1:].lower()\n        logger = proglog.default_bar_logger(logger)\n\n        if codec is None:\n            try:\n                codec = extensions_dict[ext][\"codec\"][0]\n            except KeyError:\n                raise ValueError(\n                    \"MoviePy couldn't find the codec associated \"\n                    \"with the filename. Provide the 'codec' \"\n                    \"parameter in write_videofile.\"\n                )\n\n        if audio_codec is None:\n            if ext in [\"ogv\", \"webm\"]:\n                audio_codec = \"libvorbis\"\n            else:\n                audio_codec = \"libmp3lame\"\n        elif audio_codec == \"raw16\":\n            audio_codec = \"pcm_s16le\"\n        elif audio_codec == \"raw32\":\n            audio_codec = \"pcm_s32le\"\n\n        audiofile = audio if isinstance(audio, str) else None\n        make_audio = (\n            (audiofile is None) and (audio is True) and (self.audio is not None)\n        )\n\n        if make_audio and temp_audiofile:\n            # The audio will be the clip's audio\n            audiofile = temp_audiofile\n        elif make_audio:\n            audio_ext = find_extension(audio_codec)\n            audiofile = os.path.join(\n                temp_audiofile_path,\n                name + Clip._TEMP_FILES_PREFIX + \"wvf_snd.%s\" % audio_ext,\n            )\n\n        # enough cpu for multiprocessing ? USELESS RIGHT NOW, WILL COME AGAIN\n        # enough_cpu = (multiprocessing.cpu_count() > 1)\n        logger(message=\"MoviePy - Building video %s.\" % filename)\n        if make_audio:\n            self.audio.write_audiofile(\n                audiofile,\n                audio_fps,\n                audio_nbytes,\n                audio_bufsize,\n                audio_codec,\n                bitrate=audio_bitrate,\n                write_logfile=write_logfile,\n                logger=logger,\n            )\n            # The audio is already encoded,\n            # so there is no need to encode it during video export\n            audio_codec = \"copy\"\n\n        ffmpeg_write_video(\n            self,\n            filename,\n            fps,\n            codec,\n            bitrate=bitrate,\n",
    "line_range": [
        194,
        398
    ],
    "command_specific_fields": {
        "method_name": "write_videofile"
    },
    "language": "python",
    "commit": "0f6f6d4d9b96c69d109975549fe6293931f1a19d",
    "prompt": ""
}