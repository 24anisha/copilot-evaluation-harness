{
    "case_id": "case-1438",
    "repo_name": "AntonOsika/gpt-engineer",
    "file_path": "gpt_engineer/tools/custom_steps.py",
    "code_snippet": "\n\n\n\ndef self_heal(\n\n    ai: AI,\n\n    execution_env: BaseExecutionEnv,\n\n    files_dict: FilesDict,\n\n    prompt: Prompt = None,\n\n    preprompts_holder: PrepromptsHolder = None,\n\n    memory: BaseMemory = None,\n\n) -> FilesDict:\n\n    \"\"\"\n\n    Attempts to execute the code from the entrypoint and if it fails, sends the error output back to the AI with instructions to fix.\n\n\n\n    Parameters\n\n    ----------\n\n    ai : AI\n\n        An instance of the AI model.\n\n    execution_env : BaseExecutionEnv\n\n        The execution environment where the code is run.\n\n    files_dict : FilesDict\n\n        A dictionary of file names to their contents.\n\n    preprompts_holder : PrepromptsHolder, optional\n\n        A holder for preprompt messages.\n\n\n\n    Returns\n\n    -------\n\n    FilesDict\n\n        The updated files dictionary after self-healing attempts.\n\n\n\n    Raises\n\n    ------\n\n    FileNotFoundError\n\n        If the required entrypoint file does not exist in the code.\n\n    AssertionError\n\n        If the preprompts_holder is None.\n\n\n\n    Notes\n\n    -----\n\n    This code will make `MAX_SELF_HEAL_ATTEMPTS` to try and fix the code\n\n    before giving up.\n\n    This makes the assuption that the previous step was `gen_entrypoint`,\n\n    this code could work with `simple_gen`, or `gen_clarified_code` as well.\n\n    \"\"\"\n\n\n\n    # step 1. execute the entrypoint\n\n    # log_path = dbs.workspace.path / \"log.txt\"\n\n    if ENTRYPOINT_FILE not in files_dict:\n\n        raise FileNotFoundError(\n\n            \"The required entrypoint \"\n\n            + ENTRYPOINT_FILE\n\n            + \" does not exist in the code.\"\n\n        )\n\n\n\n    attempts = 0\n\n    if preprompts_holder is None:\n\n        raise AssertionError(\"Prepromptsholder required for self-heal\")\n\n    while attempts < MAX_SELF_HEAL_ATTEMPTS:\n\n        attempts += 1\n\n        timed_out = False\n\n\n\n        # Start the process\n\n        execution_env.upload(files_dict)\n\n        p = execution_env.popen(files_dict[ENTRYPOINT_FILE])\n\n\n\n        # Wait for the process to complete and get output\n\n        stdout_full, stderr_full = p.communicate()\n\n\n\n        if (p.returncode != 0 and p.returncode != 2) and not timed_out:\n\n            print(\"run.sh failed.  The log is:\")\n\n            print(stdout_full.decode(\"utf-8\"))\n\n            print(stderr_full.decode(\"utf-8\"))\n\n\n\n            new_prompt = Prompt(\n\n                f\"A program with this specification was requested:\\n{prompt}\\n, but running it produced the following output:\\n{stdout_full}\\n and the following errors:\\n{stderr_full}. Please change it so that it fulfills the requirements.\"\n\n            )\n\n            files_dict = improve_fn(\n\n                ai, new_prompt, files_dict, memory, preprompts_holder\n\n            )\n\n        else:\n\n            break\n\n    return files_dict\n",
    "line_range": [
        38,
        118
    ],
    "command_specific_fields": {
        "method_name": "self_heal"
    },
    "language": "python",
    "commit": "c1f4a9da5dd0abed15b91f6d1c60464cad84ce6c",
    "prompt": ""
}