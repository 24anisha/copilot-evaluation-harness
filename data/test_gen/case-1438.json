{
    "case_id": "case-1438",
    "repo_name": "AntonOsika/gpt-engineer",
    "file_path": "gpt_engineer/tools/custom_steps.py",
    "code_snippet": "\n\ndef self_heal(\n    ai: AI,\n    execution_env: BaseExecutionEnv,\n    files_dict: FilesDict,\n    prompt: Prompt = None,\n    preprompts_holder: PrepromptsHolder = None,\n    memory: BaseMemory = None,\n    diff_timeout=3,\n) -> FilesDict:\n    \"\"\"\n    Attempts to execute the code from the entrypoint and if it fails, sends the error output back to the AI with instructions to fix.\n\n    Parameters\n    ----------\n    ai : AI\n        An instance of the AI model.\n    execution_env : BaseExecutionEnv\n        The execution environment where the code is run.\n    files_dict : FilesDict\n        A dictionary of file names to their contents.\n    preprompts_holder : PrepromptsHolder, optional\n        A holder for preprompt messages.\n\n    Returns\n    -------\n    FilesDict\n        The updated files dictionary after self-healing attempts.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the required entrypoint file does not exist in the code.\n    AssertionError\n        If the preprompts_holder is None.\n\n    Notes\n    -----\n    This code will make `MAX_SELF_HEAL_ATTEMPTS` to try and fix the code\n    before giving up.\n    This makes the assuption that the previous step was `gen_entrypoint`,\n    this code could work with `simple_gen`, or `gen_clarified_code` as well.\n    \"\"\"\n\n    # step 1. execute the entrypoint\n    # log_path = dbs.workspace.path / \"log.txt\"\n    if ENTRYPOINT_FILE not in files_dict:\n        raise FileNotFoundError(\n            \"The required entrypoint \"\n            + ENTRYPOINT_FILE\n            + \" does not exist in the code.\"\n        )\n\n    attempts = 0\n    if preprompts_holder is None:\n        raise AssertionError(\"Prepromptsholder required for self-heal\")\n    while attempts < MAX_SELF_HEAL_ATTEMPTS:\n        attempts += 1\n        timed_out = False\n\n        # Start the process\n        execution_env.upload(files_dict)\n        p = execution_env.popen(files_dict[ENTRYPOINT_FILE])\n\n        # Wait for the process to complete and get output\n        stdout_full, stderr_full = p.communicate()\n\n        if (p.returncode != 0 and p.returncode != 2) and not timed_out:\n            print(\"run.sh failed.  The log is:\")\n            print(stdout_full.decode(\"utf-8\"))\n            print(stderr_full.decode(\"utf-8\"))\n\n            new_prompt = Prompt(\n                f\"A program with this specification was requested:\\n{prompt}\\n, but running it produced the following output:\\n{stdout_full}\\n and the following errors:\\n{stderr_full}. Please change it so that it fulfills the requirements.\"\n            )\n            files_dict = improve_fn(\n                ai, new_prompt, files_dict, memory, preprompts_holder, diff_timeout\n            )\n        else:\n            break\n",
    "line_range": [
        38,
        118
    ],
    "command_specific_fields": {
        "method_name": "self_heal"
    },
    "language": "python",
    "commit": "c1f4a9da5dd0abed15b91f6d1c60464cad84ce6c",
    "prompt": ""
}