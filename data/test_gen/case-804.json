{
    "case_id": "case-804",
    "repo_name": "pallets/flask",
    "file_path": "src/flask/helpers.py",
    "code_snippet": "\n\ndef send_file(\n\n    path_or_file: os.PathLike[t.AnyStr] | str | t.BinaryIO,\n\n    mimetype: str | None = None,\n\n    as_attachment: bool = False,\n\n    download_name: str | None = None,\n\n    conditional: bool = True,\n\n    etag: bool | str = True,\n\n    last_modified: datetime | int | float | None = None,\n\n    max_age: None | (int | t.Callable[[str | None], int | None]) = None,\n\n) -> Response:\n\n    \"\"\"Send the contents of a file to the client.\n\n\n\n    The first argument can be a file path or a file-like object. Paths\n\n    are preferred in most cases because Werkzeug can manage the file and\n\n    get extra information from the path. Passing a file-like object\n\n    requires that the file is opened in binary mode, and is mostly\n\n    useful when building a file in memory with :class:`io.BytesIO`.\n\n\n\n    Never pass file paths provided by a user. The path is assumed to be\n\n    trusted, so a user could craft a path to access a file you didn't\n\n    intend. Use :func:`send_from_directory` to safely serve\n\n    user-requested paths from within a directory.\n\n\n\n    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n\n    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n\n    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n\n    ``USE_X_SENDFILE = True`` will tell the server to send the given\n\n    path, which is much more efficient than reading it in Python.\n\n\n\n    :param path_or_file: The path to the file to send, relative to the\n\n        current working directory if a relative path is given.\n\n        Alternatively, a file-like object opened in binary mode. Make\n\n        sure the file pointer is seeked to the start of the data.\n\n    :param mimetype: The MIME type to send for the file. If not\n\n        provided, it will try to detect it from the file name.\n\n    :param as_attachment: Indicate to a browser that it should offer to\n\n        save the file instead of displaying it.\n\n    :param download_name: The default name browsers will use when saving\n\n        the file. Defaults to the passed file name.\n\n    :param conditional: Enable conditional and range responses based on\n\n        request headers. Requires passing a file path and ``environ``.\n\n    :param etag: Calculate an ETag for the file, which requires passing\n\n        a file path. Can also be a string to use instead.\n\n    :param last_modified: The last modified time to send for the file,\n\n        in seconds. If not provided, it will try to detect it from the\n\n        file path.\n\n    :param max_age: How long the client should cache the file, in\n\n        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n\n        it will be ``no-cache`` to prefer conditional caching.\n\n\n\n    .. versionchanged:: 2.0\n\n        ``download_name`` replaces the ``attachment_filename``\n\n        parameter. If ``as_attachment=False``, it is passed with\n\n        ``Content-Disposition: inline`` instead.\n\n\n\n    .. versionchanged:: 2.0\n\n        ``max_age`` replaces the ``cache_timeout`` parameter.\n\n        ``conditional`` is enabled and ``max_age`` is not set by\n\n        default.\n\n\n\n    .. versionchanged:: 2.0\n\n        ``etag`` replaces the ``add_etags`` parameter. It can be a\n\n        string to use instead of generating one.\n\n\n\n    .. versionchanged:: 2.0\n\n        Passing a file-like object that inherits from\n\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n\n        than sending an empty file.\n\n\n\n    .. versionadded:: 2.0\n\n        Moved the implementation to Werkzeug. This is now a wrapper to\n\n        pass some Flask-specific arguments.\n\n\n\n    .. versionchanged:: 1.1\n\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n\n\n    .. versionchanged:: 1.1\n\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n\n\n    .. versionchanged:: 1.0.3\n\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n\n        compatibility with WSGI servers.\n\n\n\n    .. versionchanged:: 1.0\n\n        UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n\n\n    .. versionchanged:: 0.12\n\n        The filename is no longer automatically inferred from file\n\n        objects. If you want to use automatic MIME and etag support,\n\n        pass a filename via ``filename_or_fp`` or\n\n        ``attachment_filename``.\n\n\n\n    .. versionchanged:: 0.12\n\n        ``attachment_filename`` is preferred over ``filename`` for MIME\n\n        detection.\n\n\n\n    .. versionchanged:: 0.9\n\n        ``cache_timeout`` defaults to\n\n        :meth:`Flask.get_send_file_max_age`.\n\n\n\n    .. versionchanged:: 0.7\n\n        MIME guessing and etag support for file-like objects was\n\n        removed because it was unreliable. Pass a filename if you are\n\n        able to, otherwise attach an etag yourself.\n\n\n\n    .. versionchanged:: 0.5\n\n        The ``add_etags``, ``cache_timeout`` and ``conditional``\n\n        parameters were added. The default behavior is to add etags.\n\n\n\n    .. versionadded:: 0.2\n\n    \"\"\"\n\n    return werkzeug.utils.send_file(  # type: ignore[return-value]\n\n        **_prepare_send_file_kwargs(\n\n            path_or_file=path_or_file,\n\n            environ=request.environ,\n\n            mimetype=mimetype,\n\n            as_attachment=as_attachment,\n\n            download_name=download_name,\n\n            conditional=conditional,\n\n            etag=etag,\n\n            last_modified=last_modified,\n\n            max_age=max_age,\n\n        )\n\n    )\n",
    "line_range": [
        386,
        511
    ],
    "command_specific_fields": {
        "method_name": "send_file"
    },
    "language": "python",
    "commit": "a8956feba1e40105e7bc78fa62ce36c58d1c91e1",
    "prompt": ""
}