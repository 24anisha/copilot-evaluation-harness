{
    "case_id": "case-584",
    "repo_name": "timc1/kbar",
    "file_path": "src/useMatches.tsx",
    "code_snippet": " * returns deep matches only when a search query is present\n */\nexport function useMatches() {\n  const { search, actions, rootActionId } = useKBar((state) => ({\n    search: state.searchQuery,\n    actions: state.actions,\n    rootActionId: state.currentRootActionId,\n  }));\n\n  const rootResults = React.useMemo(() => {\n    return Object.keys(actions)\n      .reduce((acc, actionId) => {\n        const action = actions[actionId];\n        if (!action.parent && !rootActionId) {\n          acc.push(action);\n        }\n        if (action.id === rootActionId) {\n          for (let i = 0; i < action.children.length; i++) {\n            acc.push(action.children[i]);\n          }\n        }\n        return acc;\n      }, [] as ActionImpl[])\n      .sort(order);\n  }, [actions, rootActionId]);\n\n  const getDeepResults = React.useCallback((actions: ActionImpl[]) => {\n    let actionsClone: ActionImpl[] = [];\n    for (let i = 0; i < actions.length; i++) {\n      actionsClone.push(actions[i]);\n    }\n    return (function collectChildren(\n      actions: ActionImpl[],\n      all = actionsClone\n    ) {\n      for (let i = 0; i < actions.length; i++) {\n        if (actions[i].children.length > 0) {\n          let childsChildren = actions[i].children;\n          for (let i = 0; i < childsChildren.length; i++) {\n            all.push(childsChildren[i]);\n          }\n          collectChildren(actions[i].children, all);\n        }\n      }\n      return all;\n    })(actions);\n  }, []);\n\n  const emptySearch = !search;\n\n  const filtered = React.useMemo(() => {\n    if (emptySearch) return rootResults;\n    return getDeepResults(rootResults);\n  }, [getDeepResults, rootResults, emptySearch]);\n\n  const fuse = React.useMemo(() => new Fuse(filtered, fuseOptions), [filtered]);\n\n  const matches = useInternalMatches(filtered, search, fuse);\n\n  const results = React.useMemo(() => {\n    /**\n     * Store a reference to a section and it's list of actions.\n     * Alongside these actions, we'll keep a temporary record of the\n     * final priority calculated by taking the commandScore + the\n     * explicitly set `action.priority` value.\n     */\n    let map: Record<SectionName, { priority: number; action: ActionImpl }[]> =\n      {};\n    /**\n     * Store another reference to a list of sections alongside\n     * the section's final priority, calculated the same as above.\n     */\n    let list: { priority: number; name: SectionName }[] = [];\n    /**\n     * We'll take the list above and sort by its priority. Then we'll\n     * collect all actions from the map above for this specific name and\n     * sort by its priority as well.\n     */\n    let ordered: { name: SectionName; actions: ActionImpl[] }[] = [];\n\n    for (let i = 0; i < matches.length; i++) {\n      const match = matches[i];\n      const action = match.action;\n      const score = match.score || Priority.NORMAL;\n\n      const section = {\n        name:\n          typeof action.section === \"string\"\n            ? action.section\n            : action.section?.name || NO_GROUP.name,\n        priority:\n          typeof action.section === \"string\"\n            ? score\n            : action.section?.priority || 0 + score,\n      };\n\n      if (!map[section.name]) {\n        map[section.name] = [];\n        list.push(section);\n      }\n\n      map[section.name].push({\n        priority: action.priority + score,\n        action,\n      });\n    }\n\n    ordered = list.sort(order).map((group) => ({\n      name: group.name,\n      actions: map[group.name].sort(order).map((item) => item.action),\n    }));\n\n    /**\n     * Our final result is simply flattening the ordered list into\n     * our familiar (ActionImpl | string)[] shape.\n     */\n    let results: (string | ActionImpl)[] = [];\n    for (let i = 0; i < ordered.length; i++) {\n      let group = ordered[i];\n      if (group.name !== NO_GROUP.name) results.push(group.name);\n      for (let i = 0; i < group.actions.length; i++) {\n        results.push(group.actions[i]);\n      }\n    }\n    return results;\n  }, [matches]);\n\n  // ensure that users have an accurate `currentRootActionId`\n  // that syncs with the throttled return value.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoRootActionId = React.useMemo(() => rootActionId, [results]);\n\n  return React.useMemo(\n    () => ({\n      results,\n      rootActionId: memoRootActionId,\n    }),\n    [memoRootActionId, results]\n  );\n}\n",
    "line_range": [
        42,
        181
    ],
    "command_specific_fields": {
        "method_name": "useMatches"
    },
    "language": "typescript",
    "commit": "952d7c6badfe10c3b7b3bd46bbf42722ff03bfc8",
    "prompt": ""
}