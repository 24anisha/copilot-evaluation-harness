{
    "case_id": "case-584",
    "repo_name": "timc1/kbar",
    "file_path": "src/useMatches.tsx",
    "code_snippet": " * returns deep matches only when a search query is present\n\n */\n\nexport function useMatches() {\n\n  const { search, actions, rootActionId } = useKBar((state) => ({\n\n    search: state.searchQuery,\n\n    actions: state.actions,\n\n    rootActionId: state.currentRootActionId,\n\n  }));\n\n\n\n  const rootResults = React.useMemo(() => {\n\n    return Object.keys(actions)\n\n      .reduce((acc, actionId) => {\n\n        const action = actions[actionId];\n\n        if (!action.parent && !rootActionId) {\n\n          acc.push(action);\n\n        }\n\n        if (action.id === rootActionId) {\n\n          for (let i = 0; i < action.children.length; i++) {\n\n            acc.push(action.children[i]);\n\n          }\n\n        }\n\n        return acc;\n\n      }, [] as ActionImpl[])\n\n      .sort(order);\n\n  }, [actions, rootActionId]);\n\n\n\n  const getDeepResults = React.useCallback((actions: ActionImpl[]) => {\n\n    let actionsClone: ActionImpl[] = [];\n\n    for (let i = 0; i < actions.length; i++) {\n\n      actionsClone.push(actions[i]);\n\n    }\n\n    return (function collectChildren(\n\n      actions: ActionImpl[],\n\n      all = actionsClone\n\n    ) {\n\n      for (let i = 0; i < actions.length; i++) {\n\n        if (actions[i].children.length > 0) {\n\n          let childsChildren = actions[i].children;\n\n          for (let i = 0; i < childsChildren.length; i++) {\n\n            all.push(childsChildren[i]);\n\n          }\n\n          collectChildren(actions[i].children, all);\n\n        }\n\n      }\n\n      return all;\n\n    })(actions);\n\n  }, []);\n\n\n\n  const emptySearch = !search;\n\n\n\n  const filtered = React.useMemo(() => {\n\n    if (emptySearch) return rootResults;\n\n    return getDeepResults(rootResults);\n\n  }, [getDeepResults, rootResults, emptySearch]);\n\n\n\n  const fuse = React.useMemo(() => new Fuse(filtered, fuseOptions), [filtered]);\n\n\n\n  const matches = useInternalMatches(filtered, search, fuse);\n\n\n\n  const results = React.useMemo(() => {\n\n    /**\n\n     * Store a reference to a section and it's list of actions.\n\n     * Alongside these actions, we'll keep a temporary record of the\n\n     * final priority calculated by taking the commandScore + the\n\n     * explicitly set `action.priority` value.\n\n     */\n\n    let map: Record<SectionName, { priority: number; action: ActionImpl }[]> =\n\n      {};\n\n    /**\n\n     * Store another reference to a list of sections alongside\n\n     * the section's final priority, calculated the same as above.\n\n     */\n\n    let list: { priority: number; name: SectionName }[] = [];\n\n    /**\n\n     * We'll take the list above and sort by its priority. Then we'll\n\n     * collect all actions from the map above for this specific name and\n\n     * sort by its priority as well.\n\n     */\n\n    let ordered: { name: SectionName; actions: ActionImpl[] }[] = [];\n\n\n\n    for (let i = 0; i < matches.length; i++) {\n\n      const match = matches[i];\n\n      const action = match.action;\n\n      const score = match.score || Priority.NORMAL;\n\n\n\n      const section = {\n\n        name:\n\n          typeof action.section === \"string\"\n\n            ? action.section\n\n            : action.section?.name || NO_GROUP.name,\n\n        priority:\n\n          typeof action.section === \"string\"\n\n            ? score\n\n            : action.section?.priority || 0 + score,\n\n      };\n\n\n\n      if (!map[section.name]) {\n\n        map[section.name] = [];\n\n        list.push(section);\n\n      }\n\n\n\n      map[section.name].push({\n\n        priority: action.priority + score,\n\n        action,\n\n      });\n\n    }\n\n\n\n    ordered = list.sort(order).map((group) => ({\n\n      name: group.name,\n\n      actions: map[group.name].sort(order).map((item) => item.action),\n\n    }));\n\n\n\n    /**\n\n     * Our final result is simply flattening the ordered list into\n\n     * our familiar (ActionImpl | string)[] shape.\n\n     */\n\n    let results: (string | ActionImpl)[] = [];\n\n    for (let i = 0; i < ordered.length; i++) {\n\n      let group = ordered[i];\n\n      if (group.name !== NO_GROUP.name) results.push(group.name);\n\n      for (let i = 0; i < group.actions.length; i++) {\n\n        results.push(group.actions[i]);\n\n      }\n\n    }\n\n    return results;\n\n  }, [matches]);\n\n\n\n  // ensure that users have an accurate `currentRootActionId`\n\n  // that syncs with the throttled return value.\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  const memoRootActionId = React.useMemo(() => rootActionId, [results]);\n\n\n\n  return React.useMemo(\n\n    () => ({\n\n      results,\n\n      rootActionId: memoRootActionId,\n\n    }),\n\n    [memoRootActionId, results]\n\n  );\n\n}\n",
    "line_range": [
        42,
        181
    ],
    "command_specific_fields": {
        "method_name": "useMatches"
    },
    "language": "typescript",
    "commit": "952d7c6badfe10c3b7b3bd46bbf42722ff03bfc8",
    "prompt": ""
}