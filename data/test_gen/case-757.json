{
    "case_id": "case-757",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/convert_matrix.py",
    "code_snippet": "@nx._dispatchable(edge_attrs=\"weight\")\ndef to_scipy_sparse_array(G, nodelist=None, dtype=None, weight=\"weight\", format=\"csr\"):\n    \"\"\"Returns the graph adjacency matrix as a SciPy sparse array.\n\n    Parameters\n    ----------\n    G : graph\n        The NetworkX graph used to construct the sparse array.\n\n    nodelist : list, optional\n       The rows and columns are ordered according to the nodes in `nodelist`.\n       If `nodelist` is None, then the ordering is produced by ``G.nodes()``.\n\n    dtype : NumPy data-type, optional\n        A valid NumPy dtype used to initialize the array. If None, then the\n        NumPy default is used.\n\n    weight : string or None, optional (default='weight')\n        The edge attribute that holds the numerical value used for\n        the edge weight.  If None then all edge weights are 1.\n\n    format : str in {'bsr', 'csr', 'csc', 'coo', 'lil', 'dia', 'dok'}\n        The format of the sparse array to be returned (default 'csr').  For\n        some algorithms different implementations of sparse arrays\n        can perform better.  See [1]_ for details.\n\n    Returns\n    -------\n    A : SciPy sparse array\n       Graph adjacency matrix.\n\n    Notes\n    -----\n    For directed graphs, matrix entry ``i, j`` corresponds to an edge from\n    ``i`` to ``j``.\n\n    The values of the adjacency matrix are populated using the edge attribute held in\n    parameter `weight`. When an edge does not have that attribute, the\n    value of the entry is 1.\n\n    For multiple edges the matrix values are the sums of the edge weights.\n\n    When `nodelist` does not contain every node in `G`, the adjacency matrix\n    is built from the subgraph of `G` that is induced by the nodes in\n    `nodelist`.\n\n    The convention used for self-loop edges in graphs is to assign the\n    diagonal matrix entry value to the weight attribute of the edge\n    (or the number 1 if the edge has no weight attribute).  If the\n    alternate convention of doubling the edge weight is desired the\n    resulting array can be modified as follows::\n\n        >>> G = nx.Graph([(1, 1)])\n        >>> A = nx.to_scipy_sparse_array(G)\n        >>> A.toarray()\n        array([[1]])\n        >>> A.setdiag(A.diagonal() * 2)\n        >>> A.toarray()\n        array([[2]])\n\n    Examples\n    --------\n\n    Basic usage:\n\n    >>> G = nx.path_graph(4)\n    >>> A = nx.to_scipy_sparse_array(G)\n    >>> A  # doctest: +SKIP\n    <Compressed Sparse Row sparse array of dtype 'int64'\n        with 6 stored elements and shape (4, 4)>\n\n    >>> A.toarray()\n    array([[0, 1, 0, 0],\n           [1, 0, 1, 0],\n           [0, 1, 0, 1],\n           [0, 0, 1, 0]])\n\n    .. note:: The `toarray` method is used in these examples to better visualize\n       the adjacency matrix. For a dense representation of the adjaceny matrix,\n       use `to_numpy_array` instead.\n\n    Directed graphs:\n\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\n    >>> nx.to_scipy_sparse_array(G).toarray()\n    array([[0, 1, 0, 0],\n           [0, 0, 1, 0],\n           [0, 0, 0, 1],\n           [0, 0, 0, 0]])\n\n    >>> H = G.reverse()\n    >>> H.edges\n    OutEdgeView([(1, 0), (2, 1), (3, 2)])\n    >>> nx.to_scipy_sparse_array(H).toarray()\n    array([[0, 0, 0, 0],\n           [1, 0, 0, 0],\n           [0, 1, 0, 0],\n           [0, 0, 1, 0]])\n\n    By default, the order of the rows/columns of the adjacency matrix is determined\n    by the ordering of the nodes in `G`:\n\n    >>> G = nx.Graph()\n    >>> G.add_nodes_from([3, 5, 0, 1])\n    >>> G.add_edges_from([(1, 3), (1, 5)])\n    >>> nx.to_scipy_sparse_array(G).toarray()\n    array([[0, 0, 0, 1],\n           [0, 0, 0, 1],\n           [0, 0, 0, 0],\n           [1, 1, 0, 0]])\n\n    The ordering of the rows can be changed with `nodelist`:\n\n    >>> ordered = [0, 1, 3, 5]\n    >>> nx.to_scipy_sparse_array(G, nodelist=ordered).toarray()\n    array([[0, 0, 0, 0],\n           [0, 0, 1, 1],\n           [0, 1, 0, 0],\n           [0, 1, 0, 0]])\n\n    If `nodelist` contains a subset of the nodes in `G`, the adjacency matrix\n    for the node-induced subgraph is produced:\n\n    >>> nx.to_scipy_sparse_array(G, nodelist=[1, 3, 5]).toarray()\n    array([[0, 1, 1],\n           [1, 0, 0],\n           [1, 0, 0]])\n\n    The values of the adjacency matrix are drawn from the edge attribute\n    specified by the `weight` parameter:\n\n    >>> G = nx.path_graph(4)\n    >>> nx.set_edge_attributes(\n    ...     G, values={(0, 1): 1, (1, 2): 10, (2, 3): 2}, name=\"weight\"\n",
    "line_range": [
        490,
        623
    ],
    "command_specific_fields": {
        "method_name": "to_scipy_sparse_array"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}