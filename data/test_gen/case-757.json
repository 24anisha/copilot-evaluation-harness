{
    "case_id": "case-757",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/convert_matrix.py",
    "code_snippet": "\n\n\n\n@nx._dispatchable(edge_attrs=\"weight\")\n\ndef to_scipy_sparse_array(G, nodelist=None, dtype=None, weight=\"weight\", format=\"csr\"):\n\n    \"\"\"Returns the graph adjacency matrix as a SciPy sparse array.\n\n\n\n    Parameters\n\n    ----------\n\n    G : graph\n\n        The NetworkX graph used to construct the sparse matrix.\n\n\n\n    nodelist : list, optional\n\n       The rows and columns are ordered according to the nodes in `nodelist`.\n\n       If `nodelist` is None, then the ordering is produced by G.nodes().\n\n\n\n    dtype : NumPy data-type, optional\n\n        A valid NumPy dtype used to initialize the array. If None, then the\n\n        NumPy default is used.\n\n\n\n    weight : string or None   optional (default='weight')\n\n        The edge attribute that holds the numerical value used for\n\n        the edge weight.  If None then all edge weights are 1.\n\n\n\n    format : str in {'bsr', 'csr', 'csc', 'coo', 'lil', 'dia', 'dok'}\n\n        The type of the matrix to be returned (default 'csr').  For\n\n        some algorithms different implementations of sparse matrices\n\n        can perform better.  See [1]_ for details.\n\n\n\n    Returns\n\n    -------\n\n    A : SciPy sparse array\n\n       Graph adjacency matrix.\n\n\n\n    Notes\n\n    -----\n\n    For directed graphs, matrix entry i,j corresponds to an edge from i to j.\n\n\n\n    The matrix entries are populated using the edge attribute held in\n\n    parameter weight. When an edge does not have that attribute, the\n\n    value of the entry is 1.\n\n\n\n    For multiple edges the matrix values are the sums of the edge weights.\n\n\n\n    When `nodelist` does not contain every node in `G`, the adjacency matrix\n\n    is built from the subgraph of `G` that is induced by the nodes in\n\n    `nodelist`.\n\n\n\n    The convention used for self-loop edges in graphs is to assign the\n\n    diagonal matrix entry value to the weight attribute of the edge\n\n    (or the number 1 if the edge has no weight attribute).  If the\n\n    alternate convention of doubling the edge weight is desired the\n\n    resulting SciPy sparse array can be modified as follows:\n\n\n\n    >>> G = nx.Graph([(1, 1)])\n\n    >>> A = nx.to_scipy_sparse_array(G)\n\n    >>> print(A.todense())\n\n    [[1]]\n\n    >>> A.setdiag(A.diagonal() * 2)\n\n    >>> print(A.toarray())\n\n    [[2]]\n\n\n\n    Examples\n\n    --------\n\n    >>> G = nx.MultiDiGraph()\n\n    >>> G.add_edge(0, 1, weight=2)\n\n    0\n\n    >>> G.add_edge(1, 0)\n\n    0\n\n    >>> G.add_edge(2, 2, weight=3)\n\n    0\n\n    >>> G.add_edge(2, 2)\n\n    1\n\n    >>> S = nx.to_scipy_sparse_array(G, nodelist=[0, 1, 2])\n\n    >>> print(S.toarray())\n\n    [[0 2 0]\n\n     [1 0 0]\n\n     [0 0 4]]\n\n\n\n    References\n\n    ----------\n\n    .. [1] Scipy Dev. References, \"Sparse Matrices\",\n\n       https://docs.scipy.org/doc/scipy/reference/sparse.html\n\n    \"\"\"\n\n    import scipy as sp\n\n\n\n    if len(G) == 0:\n\n        raise nx.NetworkXError(\"Graph has no nodes or edges\")\n\n\n\n    if nodelist is None:\n\n        nodelist = list(G)\n\n        nlen = len(G)\n\n    else:\n\n        nlen = len(nodelist)\n\n        if nlen == 0:\n\n            raise nx.NetworkXError(\"nodelist has no nodes\")\n\n        nodeset = set(G.nbunch_iter(nodelist))\n\n        if nlen != len(nodeset):\n\n            for n in nodelist:\n\n                if n not in G:\n\n                    raise nx.NetworkXError(f\"Node {n} in nodelist is not in G\")\n\n            raise nx.NetworkXError(\"nodelist contains duplicates.\")\n\n        if nlen < len(G):\n\n            G = G.subgraph(nodelist)\n\n\n\n    index = dict(zip(nodelist, range(nlen)))\n\n    coefficients = zip(\n\n        *((index[u], index[v], wt) for u, v, wt in G.edges(data=weight, default=1))\n\n    )\n\n    try:\n\n        row, col, data = coefficients\n\n    except ValueError:\n\n        # there is no edge in the subgraph\n\n        row, col, data = [], [], []\n\n\n\n    if G.is_directed():\n\n        A = sp.sparse.coo_array((data, (row, col)), shape=(nlen, nlen), dtype=dtype)\n\n    else:\n\n        # symmetrize matrix\n\n        d = data + data\n\n        r = row + col\n\n        c = col + row\n\n        # selfloop entries get double counted when symmetrizing\n\n        # so we subtract the data on the diagonal\n\n        selfloops = list(nx.selfloop_edges(G, data=weight, default=1))\n\n        if selfloops:\n\n            diag_index, diag_data = zip(*((index[u], -wt) for u, v, wt in selfloops))\n\n            d += diag_data\n\n            r += diag_index\n\n            c += diag_index\n\n        A = sp.sparse.coo_array((d, (r, c)), shape=(nlen, nlen), dtype=dtype)\n\n    try:\n\n        return A.asformat(format)\n\n    except ValueError as err:\n\n        raise nx.NetworkXError(f\"Unknown sparse matrix format: {format}\") from err\n",
    "line_range": [
        490,
        623
    ],
    "command_specific_fields": {
        "method_name": "to_scipy_sparse_array"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}