{
    "case_id": "case-1085",
    "repo_name": "dbader/schedule",
    "file_path": "schedule/__init__.py",
    "code_snippet": "\n\n    def until(\n\n        self,\n\n        until_time: Union[datetime.datetime, datetime.timedelta, datetime.time, str],\n\n    ):\n\n        \"\"\"\n\n        Schedule job to run until the specified moment.\n\n\n\n        The job is canceled whenever the next run is calculated and it turns out the\n\n        next run is after the until_time. The job is also canceled right before it runs,\n\n        if the current time is after until_time. This latter case can happen when the\n\n        the job was scheduled to run before until_time, but runs after until_time.\n\n\n\n        If until_time is a moment in the past, ScheduleValueError is thrown.\n\n\n\n        :param until_time: A moment in the future representing the latest time a job can\n\n           be run. If only a time is supplied, the date is set to today.\n\n           The following formats are accepted:\n\n\n\n           - datetime.datetime\n\n           - datetime.timedelta\n\n           - datetime.time\n\n           - String in one of the following formats: \"%Y-%m-%d %H:%M:%S\",\n\n             \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\"\n\n             as defined by strptime() behaviour. If an invalid string format is passed,\n\n             ScheduleValueError is thrown.\n\n\n\n        :return: The invoked job instance\n\n        \"\"\"\n\n\n\n        if isinstance(until_time, datetime.datetime):\n\n            self.cancel_after = until_time\n\n        elif isinstance(until_time, datetime.timedelta):\n\n            self.cancel_after = datetime.datetime.now() + until_time\n\n        elif isinstance(until_time, datetime.time):\n\n            self.cancel_after = datetime.datetime.combine(\n\n                datetime.datetime.now(), until_time\n\n            )\n\n        elif isinstance(until_time, str):\n\n            cancel_after = self._decode_datetimestr(\n\n                until_time,\n\n                [\n\n                    \"%Y-%m-%d %H:%M:%S\",\n\n                    \"%Y-%m-%d %H:%M\",\n\n                    \"%Y-%m-%d\",\n\n                    \"%H:%M:%S\",\n\n                    \"%H:%M\",\n\n                ],\n\n            )\n\n            if cancel_after is None:\n\n                raise ScheduleValueError(\"Invalid string format for until()\")\n\n            if \"-\" not in until_time:\n\n                # the until_time is a time-only format. Set the date to today\n\n                now = datetime.datetime.now()\n\n                cancel_after = cancel_after.replace(\n\n                    year=now.year, month=now.month, day=now.day\n\n                )\n\n            self.cancel_after = cancel_after\n\n        else:\n\n            raise TypeError(\n\n                \"until() takes a string, datetime.datetime, datetime.timedelta, \"\n\n                \"datetime.time parameter\"\n\n            )\n\n        if self.cancel_after < datetime.datetime.now():\n\n            raise ScheduleValueError(\n\n                \"Cannot schedule a job to run until a time in the past\"\n\n            )\n\n        return self\n",
    "line_range": [
        574,
        642
    ],
    "command_specific_fields": {
        "method_name": "until"
    },
    "language": "python",
    "commit": "82a43db1b938d8fdf60103bd41f329e06c8d3651",
    "prompt": ""
}