{
    "case_id": "case-1085",
    "repo_name": "dbader/schedule",
    "file_path": "schedule/__init__.py",
    "code_snippet": "        return self\n\n    def until(\n        self,\n        until_time: Union[datetime.datetime, datetime.timedelta, datetime.time, str],\n    ):\n        \"\"\"\n        Schedule job to run until the specified moment.\n\n        The job is canceled whenever the next run is calculated and it turns out the\n        next run is after the until_time. The job is also canceled right before it runs,\n        if the current time is after until_time. This latter case can happen when the\n        the job was scheduled to run before until_time, but runs after until_time.\n\n        If until_time is a moment in the past, ScheduleValueError is thrown.\n\n        :param until_time: A moment in the future representing the latest time a job can\n           be run. If only a time is supplied, the date is set to today.\n           The following formats are accepted:\n\n           - datetime.datetime\n           - datetime.timedelta\n           - datetime.time\n           - String in one of the following formats: \"%Y-%m-%d %H:%M:%S\",\n             \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\"\n             as defined by strptime() behaviour. If an invalid string format is passed,\n             ScheduleValueError is thrown.\n\n        :return: The invoked job instance\n        \"\"\"\n\n        if isinstance(until_time, datetime.datetime):\n            self.cancel_after = until_time\n        elif isinstance(until_time, datetime.timedelta):\n            self.cancel_after = datetime.datetime.now() + until_time\n        elif isinstance(until_time, datetime.time):\n            self.cancel_after = datetime.datetime.combine(\n                datetime.datetime.now(), until_time\n            )\n        elif isinstance(until_time, str):\n            cancel_after = self._decode_datetimestr(\n                until_time,\n                [\n                    \"%Y-%m-%d %H:%M:%S\",\n                    \"%Y-%m-%d %H:%M\",\n                    \"%Y-%m-%d\",\n                    \"%H:%M:%S\",\n                    \"%H:%M\",\n                ],\n            )\n            if cancel_after is None:\n                raise ScheduleValueError(\"Invalid string format for until()\")\n            if \"-\" not in until_time:\n                # the until_time is a time-only format. Set the date to today\n                now = datetime.datetime.now()\n                cancel_after = cancel_after.replace(\n                    year=now.year, month=now.month, day=now.day\n                )\n            self.cancel_after = cancel_after\n        else:\n            raise TypeError(\n                \"until() takes a string, datetime.datetime, datetime.timedelta, \"\n                \"datetime.time parameter\"\n            )\n        if self.cancel_after < datetime.datetime.now():\n            raise ScheduleValueError(\n                \"Cannot schedule a job to run until a time in the past\"\n            )\n        return self\n",
    "line_range": [
        574,
        642
    ],
    "command_specific_fields": {
        "method_name": "until"
    },
    "language": "python",
    "commit": "82a43db1b938d8fdf60103bd41f329e06c8d3651",
    "prompt": ""
}