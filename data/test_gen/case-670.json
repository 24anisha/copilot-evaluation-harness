{
    "case_id": "case-670",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/algorithms/centrality/reaching.py",
    "code_snippet": "\n\n@nx._dispatchable(edge_attrs=\"weight\")\n\ndef local_reaching_centrality(G, v, paths=None, weight=None, normalized=True):\n\n    \"\"\"Returns the local reaching centrality of a node in a directed\n\n    graph.\n\n\n\n    The *local reaching centrality* of a node in a directed graph is the\n\n    proportion of other nodes reachable from that node [1]_.\n\n\n\n    Parameters\n\n    ----------\n\n    G : DiGraph\n\n        A NetworkX DiGraph.\n\n\n\n    v : node\n\n        A node in the directed graph `G`.\n\n\n\n    paths : dictionary (default=None)\n\n        If this is not `None` it must be a dictionary representation\n\n        of single-source shortest paths, as computed by, for example,\n\n        :func:`networkx.shortest_path` with source node `v`. Use this\n\n        keyword argument if you intend to invoke this function many\n\n        times but don't want the paths to be recomputed each time.\n\n\n\n    weight : None or string, optional (default=None)\n\n        Attribute to use for edge weights.  If `None`, each edge weight\n\n        is assumed to be one. A higher weight implies a stronger\n\n        connection between nodes and a *shorter* path length.\n\n\n\n    normalized : bool, optional (default=True)\n\n        Whether to normalize the edge weights by the total sum of edge\n\n        weights.\n\n\n\n    Returns\n\n    -------\n\n    h : float\n\n        The local reaching centrality of the node ``v`` in the graph\n\n        ``G``.\n\n\n\n    Examples\n\n    --------\n\n    >>> G = nx.DiGraph()\n\n    >>> G.add_edges_from([(1, 2), (1, 3)])\n\n    >>> nx.local_reaching_centrality(G, 3)\n\n    0.0\n\n    >>> G.add_edge(3, 2)\n\n    >>> nx.local_reaching_centrality(G, 3)\n\n    0.5\n\n\n\n    See also\n\n    --------\n\n    global_reaching_centrality\n\n\n\n    References\n\n    ----------\n\n    .. [1] Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n\n           \"Hierarchy Measure for Complex Networks.\"\n\n           *PLoS ONE* 7.3 (2012): e33799.\n\n           https://doi.org/10.1371/journal.pone.0033799\n\n    \"\"\"\n\n    if paths is None:\n\n        if nx.is_negatively_weighted(G, weight=weight):\n\n            raise nx.NetworkXError(\"edge weights must be positive\")\n\n        total_weight = G.size(weight=weight)\n\n        if total_weight <= 0:\n\n            raise nx.NetworkXError(\"Size of G must be positive\")\n\n        if weight is not None:\n\n            # Interpret weights as lengths.\n\n            def as_distance(u, v, d):\n\n                return total_weight / d.get(weight, 1)\n\n\n\n            paths = nx.shortest_path(G, source=v, weight=as_distance)\n\n        else:\n\n            paths = nx.shortest_path(G, source=v)\n\n    # If the graph is unweighted, simply return the proportion of nodes\n\n    # reachable from the source node ``v``.\n\n    if weight is None and G.is_directed():\n\n        return (len(paths) - 1) / (len(G) - 1)\n\n    if normalized and weight is not None:\n\n        norm = G.size(weight=weight) / G.size()\n\n    else:\n\n        norm = 1\n\n    # TODO This can be trivially parallelized.\n\n    avgw = (_average_weight(G, path, weight=weight) for path in paths.values())\n\n    sum_avg_weight = sum(avgw) / norm\n\n    return sum_avg_weight / (len(G) - 1)\n",
    "line_range": [
        120,
        206
    ],
    "command_specific_fields": {
        "method_name": "local_reaching_centrality"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}