{
    "case_id": "case-670",
    "repo_name": "networkx/networkx",
    "file_path": "networkx/algorithms/centrality/reaching.py",
    "code_snippet": "\n@nx._dispatchable(edge_attrs=\"weight\")\ndef local_reaching_centrality(G, v, paths=None, weight=None, normalized=True):\n    \"\"\"Returns the local reaching centrality of a node in a directed\n    graph.\n\n    The *local reaching centrality* of a node in a directed graph is the\n    proportion of other nodes reachable from that node [1]_.\n\n    Parameters\n    ----------\n    G : DiGraph\n        A NetworkX DiGraph.\n\n    v : node\n        A node in the directed graph `G`.\n\n    paths : dictionary (default=None)\n        If this is not `None` it must be a dictionary representation\n        of single-source shortest paths, as computed by, for example,\n        :func:`networkx.shortest_path` with source node `v`. Use this\n        keyword argument if you intend to invoke this function many\n        times but don't want the paths to be recomputed each time.\n\n    weight : None or string, optional (default=None)\n        Attribute to use for edge weights.  If `None`, each edge weight\n        is assumed to be one. A higher weight implies a stronger\n        connection between nodes and a *shorter* path length.\n\n    normalized : bool, optional (default=True)\n        Whether to normalize the edge weights by the total sum of edge\n        weights.\n\n    Returns\n    -------\n    h : float\n        The local reaching centrality of the node ``v`` in the graph\n        ``G``.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_edges_from([(1, 2), (1, 3)])\n    >>> nx.local_reaching_centrality(G, 3)\n    0.0\n    >>> G.add_edge(3, 2)\n    >>> nx.local_reaching_centrality(G, 3)\n    0.5\n\n    See also\n    --------\n    global_reaching_centrality\n\n    References\n    ----------\n    .. [1] Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n           \"Hierarchy Measure for Complex Networks.\"\n           *PLoS ONE* 7.3 (2012): e33799.\n           https://doi.org/10.1371/journal.pone.0033799\n    \"\"\"\n    # Corner case: graph with single node containing a self-loop\n    if (total_weight := G.size(weight=weight)) > 0 and len(G) == 1:\n        raise nx.NetworkXError(\n            \"local_reaching_centrality of a single node with self-loop not well-defined\"\n        )\n    if paths is None:\n        if nx.is_negatively_weighted(G, weight=weight):\n            raise nx.NetworkXError(\"edge weights must be positive\")\n        if total_weight <= 0:\n            raise nx.NetworkXError(\"Size of G must be positive\")\n        if weight is not None:\n            # Interpret weights as lengths.\n            def as_distance(u, v, d):\n                return total_weight / d.get(weight, 1)\n\n            paths = nx.shortest_path(G, source=v, weight=as_distance)\n        else:\n            paths = nx.shortest_path(G, source=v)\n    # If the graph is unweighted, simply return the proportion of nodes\n    # reachable from the source node ``v``.\n    if weight is None and G.is_directed():\n        return (len(paths) - 1) / (len(G) - 1)\n    if normalized and weight is not None:\n        norm = G.size(weight=weight) / G.size()\n    else:\n        norm = 1\n    # TODO This can be trivially parallelized.\n",
    "line_range": [
        120,
        206
    ],
    "command_specific_fields": {
        "method_name": "local_reaching_centrality"
    },
    "language": "python",
    "commit": "89718e0514bded93ded5b00aed755a4474c1dc6f",
    "prompt": ""
}