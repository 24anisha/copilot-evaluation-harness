{
    "case_id": "case-482",
    "repo_name": "kelektiv/node-cron",
    "file_path": "src/time.ts",
    "code_snippet": "\n\t\t// Setting the seconds and milliseconds to zero is necessary for two reasons:\n\t\t// Firstly, the range checking function needs the earliest moment after the jump.\n\t\t// Secondly, this DateTime may be used for scheduling jobs, if there existed a job in the skipped range.\n\t\tconst afterJumpingPoint = maybeJumpingPoint\n\t\t\t.plus({ minute: 1 }) // back to the first minute _after_ the jump\n\t\t\t.set({ second: 0, millisecond: 0 });\n\n\t\t// Get the lower bound of the range to check as well. This only has to be accurate down to minutes.\n\t\tconst beforeJumpingPoint = afterJumpingPoint.minus({ second: 1 });\n\n\t\tif (\n\t\t\tdate.month in this.month &&\n\t\t\tdate.day in this.dayOfMonth &&\n\t\t\tthis._getWeekDay(date) in this.dayOfWeek\n\t\t) {\n\t\t\treturn [\n\t\t\t\tthis._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint),\n\t\t\t\tafterJumpingPoint\n\t\t\t];\n\t\t}\n\n\t\t// no valid time in the range for sure, units that didn't change from the skip mismatch.\n\t\treturn [false, afterJumpingPoint];\n\t}\n\n\t/**\n\t * Given 2 DateTimes, which represent 1 second before and immediately after a DST forward jump,\n\t * checks if a time in the skipped range would have been a valid CronJob time.\n\t *\n\t * Could technically work with just one of these values, extracting the other by adding or subtracting seconds.\n\t * However, this couples the input DateTime to actually being tied to a DST jump,\n\t * which would make the function harder to test.\n\t * This way the logic just tests a range of minutes and hours, regardless if there are skipped time points underneath.\n\t *\n\t * Assumes the DST jump started no earlier than 0:00 and jumped forward by at least 1 minute, to at most 23:59.\n\t * i.e. The day is assumed constant, but the jump is not assumed to be an hour long.\n\t * Empirically, it is almost always one hour, but very, very rarely 30 minutes.\n\t *\n\t * Assumes dayOfWeek, dayOfMonth and month match all match, so only the hours, minutes and seconds are to be checked.\n\t * @param {DateTime} beforeJumpingPoint\n\t * @param {DateTime} afterJumpingPoint\n\t * @returns {boolean}\n\t */\n\tprivate _checkTimeInSkippedRange(\n\t\tbeforeJumpingPoint: DateTime,\n\t\tafterJumpingPoint: DateTime\n\t) {\n\t\t// start by getting the first minute & hour inside the skipped range.\n\t\tconst startingMinute = (beforeJumpingPoint.minute + 1) % 60;\n\t\tconst startingHour =\n\t\t\t(beforeJumpingPoint.hour + (startingMinute === 0 ? 1 : 0)) % 24;\n\n\t\tconst hourRangeSize = afterJumpingPoint.hour - startingHour + 1;\n\t\tconst isHourJump = startingMinute === 0 && afterJumpingPoint.minute === 0;\n\n\t\t// There exist DST jumps other than 1 hour long, and the function is built to deal with it.\n\t\t// It may be overkill to assume some cases, but it shouldn't cost much at runtime.\n",
    "line_range": [
        423,
        480
    ],
    "command_specific_fields": {
        "method_name": "_findPreviousDSTJump"
    },
    "language": "typescript",
    "commit": "1eb978b8cddf8a2f2bead841adcad408238333c6",
    "prompt": ""
}